[{"filePath": "C:\\DEV\\projects\\_git\\ossf-sast-ml\\cli.js", "messages": [{"functionBody": "async function(args) {\r\n    if (Array.isArray(args)) {\r\n        console.log(\"CLI args: %o\", args.slice(2));\r\n    }\r\n\r\n    let options;\r\n\r\n    try {\r\n        options = optionator({\r\n            prepend: \"my_module [options] [dir]\",\r\n\r\n            defaults: {\r\n                concatRepeatedArrays: true,\r\n                mergeRepeatedObjects: true\r\n            },\r\n\r\n            options: [{\r\n                heading: \"Output\"\r\n            }, {\r\n                option: \"output-file\",\r\n                alias: \"o\",\r\n                type: \"path::String\",\r\n                default: \"result.json\",\r\n                description: \"Specify file to write report to\"\r\n            }, {\r\n                heading: \"Miscellaneous\"\r\n            }, {\r\n                option: \"help\",\r\n                alias: \"h\",\r\n                type: \"Boolean\",\r\n                description: \"Show help\"\r\n            }]\r\n        }).parse(args);\r\n    } catch (error) {\r\n        console.log(error.message);\r\n        return 2;\r\n    }\r\n\r\n    console.log(\"Parsed args: %o\", options);\r\n\r\n    if (options.help) {\r\n        console.log(options.generateHelp());\r\n        return 0;\r\n    }\r\n\r\n    let files = options._;\r\n    let res = await lint.execute(files, options.outputFile);\r\n    console.log(JSON.stringify(res));\r\n    return 0;\r\n}", "startLine": 5, "endLine": 57, "nodeType": "FunctionExpression", "vulnerable": 1}]}, {"filePath": "C:\\DEV\\projects\\_git\\ossf-sast-ml\\lint.js", "messages": [{"functionBody": "function findAllFunctions(root, functionsList) {\r\n    if (!root)\r\n        return;\r\n\r\n    if (!!root.forEach) {\r\n        root.forEach(el => {\r\n            findAllFunctions(el, functionsList);\r\n        });\r\n    }\r\n\r\n    if (!root.type)\r\n        return;\r\n\r\n    if (!!root.type && root.type.includes(\"Function\")) {\r\n        let functionBody = recast.print(root).code;\r\n\r\n        functionsList.push({\r\n            functionBody,\r\n            startLine: root.loc.start.line,\r\n            endLine: root.loc.end.line,\r\n            nodeType: root.type\r\n        });\r\n    }\r\n\r\n    (Object.keys(root) || []).forEach(k => {\r\n        findAllFunctions(root[k], functionsList);\r\n    });\r\n}", "startLine": 8, "endLine": 25, "nodeType": "FunctionDeclaration", "vulnerable": 1}, {"functionBody": "function extractFunctionsFromFile(filePath) {\r\n    let file = fs.readFileSync(path.resolve(filePath), \"utf8\");\r\n\r\n    let functionArg = acornLoose.parse(file, {\r\n        locations: true\r\n    });\r\n\r\n    let functions = [];\r\n    findAllFunctions(functionArg, functions);\r\n    return functions;\r\n}", "startLine": 27, "endLine": 33, "nodeType": "FunctionDeclaration", "vulnerable": 1}, {"functionBody": "function isCodeDir(dirName) {\r\n    return ![\r\n        \"node_modules\",\r\n        \".idea\",\r\n        \"test\",\r\n        \"tests\",\r\n        \"build\",\r\n        \"dist\",\r\n        \"assets\",\r\n        \"docs\",\r\n        \"venv\"\r\n    ].includes(dirName);\r\n}", "startLine": 35, "endLine": 37, "nodeType": "FunctionDeclaration", "vulnerable": 1}, {"functionBody": "function isCodeFile(fileName) {\r\n    let parsedFileName = path.parse(fileName);\r\n    return [\".js\", \".ts\", \".mjs\", \".mts\"].includes(parsedFileName.ext) && ![\"package\"].includes(parsedFileName.name);\r\n}", "startLine": 39, "endLine": 42, "nodeType": "FunctionDeclaration", "vulnerable": 1}, {"functionBody": "function listFiles(filePath) {\r\n    let pathInfo = fs.lstatSync(filePath, {\r\n        throwIfNoEntry: false\r\n    });\r\n\r\n    if (pathInfo?.isFile()) {\r\n        return [filePath];\r\n    } else if (!pathInfo?.isDirectory()) {\r\n        return [];\r\n    }\r\n\r\n    let files = [];\r\n\r\n    fs.readdirSync(filePath).forEach(fileName => {\r\n        let file = filePath + path.sep + fileName;\r\n        let fileInfo = fs.lstatSync(file);\r\n\r\n        if (fileInfo.isDirectory() && isCodeDir(fileName))\r\n            files.push(...listFiles(file));\r\n        else if (fileInfo.isFile() && isCodeFile(fileName))\r\n            files.push(file);\r\n    });\r\n\r\n    return files;\r\n}", "startLine": 44, "endLine": 59, "nodeType": "FunctionDeclaration", "vulnerable": 1}, {"functionBody": "fileName => {\r\n    let file = filePath + path.sep + fileName;\r\n    let fileInfo = fs.lstatSync(file);\r\n\r\n    if (fileInfo.isDirectory() && isCodeDir(fileName))\r\n        files.push(...listFiles(file));\r\n    else if (fileInfo.isFile() && isCodeFile(fileName))\r\n        files.push(file);\r\n}", "startLine": 52, "endLine": 57, "nodeType": "ArrowFunctionExpression", "vulnerable": 1}, {"functionBody": "function extractFunctionsFromPaths(paths, outFile) {\r\n    if (!outFile) {\r\n        outFile = \"result.json\";\r\n    }\r\n\r\n    let data = [];\r\n\r\n    paths.forEach(path => {\r\n        listFiles(path).forEach(filePath => {\r\n            data.push({\r\n                filePath,\r\n                messages: extractFunctionsFromFile(filePath)\r\n            });\r\n\r\n            data[filePath] = extractFunctionsFromFile(filePath);\r\n        });\r\n    });\r\n\r\n    fs.writeFile(outFile, JSON.stringify(data), \"utf8\", err => {\r\n        if (err)\r\n            console.log(\"Something went wrong: \", err);\r\n    });\r\n\r\n    return outFile;\r\n}", "startLine": 61, "endLine": 79, "nodeType": "FunctionDeclaration", "vulnerable": 1}, {"functionBody": "path => {\r\n    listFiles(path).forEach(filePath => {\r\n        data.push({\r\n            filePath,\r\n            messages: extractFunctionsFromFile(filePath)\r\n        });\r\n\r\n        data[filePath] = extractFunctionsFromFile(filePath);\r\n    });\r\n}", "startLine": 66, "endLine": 74, "nodeType": "ArrowFunctionExpression", "vulnerable": 1}, {"functionBody": "filePath => {\r\n    data.push({\r\n        filePath,\r\n        messages: extractFunctionsFromFile(filePath)\r\n    });\r\n\r\n    data[filePath] = extractFunctionsFromFile(filePath);\r\n}", "startLine": 67, "endLine": 73, "nodeType": "ArrowFunctionExpression", "vulnerable": 1}, {"functionBody": "async (paths, output) => {\r\n    console.log(\"Execute: (paths=\", paths, \", output=\\\"\" + output + \"\\\")\");\r\n    let outFile = extractFunctionsFromPaths(paths, output);\r\n\r\n    try {\r\n        let cmdRes = await exec(`inference ${outFile}`);\r\n        let res = cmdRes.stdout.trim();\r\n        console.log(res);\r\n    } catch (e) {\r\n        throw new Error(\"Could not run inference for \" + outFile + \", error: \" + e);\r\n    }\r\n\r\n    return outFile;\r\n}", "startLine": 81, "endLine": 92, "nodeType": "ArrowFunctionExpression", "vulnerable": 1}]}, {"filePath": "C:\\DEV\\projects\\_git\\ossf-sast-ml\\myTool.js", "messages": [{"functionBody": "function onFatalError(error) {\r\n    process.exitCode = 2;\r\n\r\n    const {\r\n        version\r\n    } = require(\"./package.json\");\r\n\r\n    console.error(`\r\nOops! Something went wrong! :(\r\n\r\nMyTool: ${version}\r\n\r\n${error}`);\r\n}", "startLine": 6, "endLine": 17, "nodeType": "FunctionDeclaration", "vulnerable": 1}, {"functionBody": "async function main() {\r\n    process.on(\"uncaughtException\", onFatalError);\r\n    process.on(\"unhandledRejection\", onFatalError);\r\n    process.exitCode = await require(\"./cli\").execute(process.argv);\r\n}", "startLine": 23, "endLine": 27, "nodeType": "FunctionExpression", "vulnerable": 1}]}]