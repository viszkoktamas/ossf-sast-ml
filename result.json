[{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\benchmark\\implementations\\commonmark-reference\\index.js","messages":[{"functionBody":"function(data) {\r\n    return renderer.render(parser.parse(data));\r\n}","startLine":7,"endLine":9,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\benchmark\\implementations\\current\\index.js","messages":[{"functionBody":"function(data) {\r\n    return md.render(data);\r\n}","startLine":10,"endLine":12,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\benchmark\\implementations\\current-commonmark\\index.js","messages":[{"functionBody":"function(data) {\r\n    return md.render(data);\r\n}","startLine":6,"endLine":8,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\benchmark\\implementations\\marked-0.3.2\\index.js","messages":[{"functionBody":"function(data) {\r\n    return marked(data);\r\n}","startLine":5,"endLine":7,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\benchmark\\index.js","messages":[{"functionBody":"function(name) {\r\n    var file = path.join(IMPLS_DIRECTORY, name);\r\n    var code = require(file);\r\n    IMPLS_PATHS[name] = file;\r\n\r\n    IMPLS.push({\r\n        name: name,\r\n        code: code\r\n    });\r\n}","startLine":18,"endLine":27,"nodeType":"FunctionExpression"},{"functionBody":"function(sample) {\r\n    var filepath = path.join(FIXTURES_DIRECTORY, sample);\r\n    var extname = path.extname(filepath);\r\n    var basename = path.basename(filepath, extname);\r\n    var content = {};\r\n    content.string = fs.readFileSync(filepath, \"utf8\");\r\n    var title = util.format(\"(%d bytes)\", content.string.length);\r\n\r\n    function onComplete() {\r\n        cursor.write(\"\\n\");\r\n    }\r\n\r\n    var suite = new Benchmark.Suite(title, {\r\n        onStart: function onStart() {\r\n            console.log(\"\\nSample: %s %s\", sample, title);\r\n        },\r\n\r\n        onComplete: onComplete\r\n    });\r\n\r\n    IMPLS.forEach(function(impl) {\r\n        suite.add(impl.name, {\r\n            onCycle: function onCycle(event) {\r\n                cursor.horizontalAbsolute();\r\n                cursor.eraseLine();\r\n                cursor.write(\" > \" + event.target);\r\n            },\r\n\r\n            onComplete: onComplete,\r\n\r\n            fn: function() {\r\n                impl.code.run(content.string);\r\n                return;\r\n            }\r\n        });\r\n    });\r\n\r\n    FIXTURES.push({\r\n        name: basename,\r\n        title: title,\r\n        content: content,\r\n        suite: suite\r\n    });\r\n}","startLine":33,"endLine":76,"nodeType":"FunctionExpression"},{"functionBody":"function onComplete() {\r\n    cursor.write(\"\\n\");\r\n}","startLine":42,"endLine":44,"nodeType":"FunctionDeclaration"},{"functionBody":"function onStart() {\r\n    console.log(\"\\nSample: %s %s\", sample, title);\r\n}","startLine":47,"endLine":49,"nodeType":"FunctionExpression"},{"functionBody":"function(impl) {\r\n    suite.add(impl.name, {\r\n        onCycle: function onCycle(event) {\r\n            cursor.horizontalAbsolute();\r\n            cursor.eraseLine();\r\n            cursor.write(\" > \" + event.target);\r\n        },\r\n\r\n        onComplete: onComplete,\r\n\r\n        fn: function() {\r\n            impl.code.run(content.string);\r\n            return;\r\n        }\r\n    });\r\n}","startLine":54,"endLine":67,"nodeType":"FunctionExpression"},{"functionBody":"function onCycle(event) {\r\n    cursor.horizontalAbsolute();\r\n    cursor.eraseLine();\r\n    cursor.write(\" > \" + event.target);\r\n}","startLine":56,"endLine":60,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    impl.code.run(content.string);\r\n    return;\r\n}","startLine":62,"endLine":65,"nodeType":"FunctionExpression"},{"functionBody":"function select(patterns) {\r\n    var result = [];\r\n\r\n    if (!(patterns instanceof Array)) {\r\n        patterns = [patterns];\r\n    }\r\n\r\n    function checkName(name) {\r\n        return patterns.length === 0 || patterns.some(function(regexp) {\r\n            return regexp.test(name);\r\n        });\r\n    }\r\n\r\n    FIXTURES.forEach(function(sample) {\r\n        if (checkName(sample.name)) {\r\n            result.push(sample);\r\n        }\r\n    });\r\n\r\n    return result;\r\n}","startLine":79,"endLine":99,"nodeType":"FunctionDeclaration"},{"functionBody":"function checkName(name) {\r\n    return patterns.length === 0 || patterns.some(function(regexp) {\r\n        return regexp.test(name);\r\n    });\r\n}","startLine":86,"endLine":90,"nodeType":"FunctionDeclaration"},{"functionBody":"function(regexp) {\r\n    return regexp.test(name);\r\n}","startLine":87,"endLine":89,"nodeType":"FunctionExpression"},{"functionBody":"function(sample) {\r\n    if (checkName(sample.name)) {\r\n        result.push(sample);\r\n    }\r\n}","startLine":92,"endLine":96,"nodeType":"FunctionExpression"},{"functionBody":"function run(files) {\r\n    var selected = select(files);\r\n\r\n    if (selected.length > 0) {\r\n        console.log(\"Selected fixtures: (%d of %d)\", selected.length, FIXTURES.length);\r\n\r\n        selected.forEach(function(sample) {\r\n            console.log(\" > %s\", sample.name);\r\n        });\r\n    } else {\r\n        console.log(\r\n            \"There isn't any sample matches any of these patterns: %s\",\r\n            util.inspect(files)\r\n        );\r\n    }\r\n\r\n    selected.forEach(function(sample) {\r\n        sample.suite.run();\r\n    });\r\n}","startLine":102,"endLine":117,"nodeType":"FunctionDeclaration"},{"functionBody":"function(sample) {\r\n    console.log(\" > %s\", sample.name);\r\n}","startLine":107,"endLine":109,"nodeType":"FunctionExpression"},{"functionBody":"function(sample) {\r\n    sample.suite.run();\r\n}","startLine":114,"endLine":116,"nodeType":"FunctionExpression"},{"functionBody":"function(source) {\r\n    return new RegExp(source, \"i\");\r\n}","startLine":127,"endLine":129,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\benchmark\\profile.js","messages":[]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\bin\\remarkable.js","messages":[{"functionBody":"function readFile(filename, encoding, callback) {\r\n    if (options.file === \"-\") {\r\n        var chunks = [];\r\n\r\n        process.stdin.on(\"data\", function(chunk) {\r\n            chunks.push(chunk);\r\n        });\r\n\r\n        process.stdin.on(\"end\", function() {\r\n            return callback(null, Buffer.concat(chunks).toString(encoding));\r\n        });\r\n    } else {\r\n        fs.readFile(filename, encoding, callback);\r\n    }\r\n}","startLine":29,"endLine":44,"nodeType":"FunctionDeclaration"},{"functionBody":"function(chunk) {\r\n    chunks.push(chunk);\r\n}","startLine":34,"endLine":36,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return callback(null, Buffer.concat(chunks).toString(encoding));\r\n}","startLine":38,"endLine":40,"nodeType":"FunctionExpression"},{"functionBody":"function(err, input) {\r\n    var output, md;\r\n\r\n    if (err) {\r\n        if (err.code === \"ENOENT\") {\r\n            console.error(\"File not found: \" + options.file);\r\n            process.exit(2);\r\n        }\r\n\r\n        console.error(err.stack || err.message || String(err));\r\n        process.exit(1);\r\n    }\r\n\r\n    md = new Remarkable(\"full\", {\r\n        html: true,\r\n        xhtmlOut: true,\r\n        typographer: true,\r\n        linkify: true\r\n    });\r\n\r\n    try {\r\n        output = md.render(input);\r\n    } catch (e) {\r\n        console.error(e.stack || e.message || String(e));\r\n        process.exit(1);\r\n    }\r\n\r\n    process.stdout.write(output);\r\n    process.exit(0);\r\n}","startLine":49,"endLine":78,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\demo\\example.js","messages":[{"functionBody":"function(str, lang) {\r\n    if (lang && hljs.getLanguage(lang)) {\r\n        try {\r\n            return hljs.highlight(lang, str).value;\r\n        } catch (__) {}\r\n    }\r\n\r\n    try {\r\n        return hljs.highlightAuto(str).value;\r\n    } catch (__) {}\r\n\r\n    return \"\";\r\n}","startLine":21,"endLine":33,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\index.js","messages":[]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\common\\entities.js","messages":[]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\common\\html_blocks.js","messages":[{"functionBody":"function(name) {\r\n    html_blocks[name] = true;\r\n}","startLine":59,"endLine":59,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\common\\html_re.js","messages":[{"functionBody":"function replace(regex, options) {\r\n    regex = regex.source;\r\n    options = options || \"\";\r\n\r\n    return function self(name, val) {\r\n        if (!name) {\r\n            return new RegExp(regex, options);\r\n        }\r\n\r\n        val = val.source || val;\r\n        regex = regex.replace(name, val);\r\n        return self;\r\n    };\r\n}","startLine":6,"endLine":18,"nodeType":"FunctionDeclaration"},{"functionBody":"function self(name, val) {\r\n    if (!name) {\r\n        return new RegExp(regex, options);\r\n    }\r\n\r\n    val = val.source || val;\r\n    regex = regex.replace(name, val);\r\n    return self;\r\n}","startLine":10,"endLine":17,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\common\\url_schemas.js","messages":[]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\common\\utils.js","messages":[{"functionBody":"function typeOf(obj) {\r\n    return Object.prototype.toString.call(obj);\r\n}","startLine":7,"endLine":9,"nodeType":"FunctionDeclaration"},{"functionBody":"function isString(obj) {\r\n    return typeOf(obj) === \"[object String]\";\r\n}","startLine":11,"endLine":13,"nodeType":"FunctionDeclaration"},{"functionBody":"function has(object, key) {\r\n    return object ? hasOwn.call(object, key) : false;\r\n}","startLine":17,"endLine":21,"nodeType":"FunctionDeclaration"},{"functionBody":"function assign(obj) {\r\n    var sources = [].slice.call(arguments, 1);\r\n\r\n    sources.forEach(function(source) {\r\n        if (!source) {\r\n            return;\r\n        }\r\n\r\n        if (typeof source !== \"object\") {\r\n            throw new TypeError(source + \"must be object\");\r\n        }\r\n\r\n        Object.keys(source).forEach(function(key) {\r\n            obj[key] = source[key];\r\n        });\r\n    });\r\n\r\n    return obj;\r\n}","startLine":25,"endLine":41,"nodeType":"FunctionDeclaration"},{"functionBody":"function(source) {\r\n    if (!source) {\r\n        return;\r\n    }\r\n\r\n    if (typeof source !== \"object\") {\r\n        throw new TypeError(source + \"must be object\");\r\n    }\r\n\r\n    Object.keys(source).forEach(function(key) {\r\n        obj[key] = source[key];\r\n    });\r\n}","startLine":28,"endLine":38,"nodeType":"FunctionExpression"},{"functionBody":"function(key) {\r\n    obj[key] = source[key];\r\n}","startLine":35,"endLine":37,"nodeType":"FunctionExpression"},{"functionBody":"function unescapeMd(str) {\r\n    if (str.indexOf(\"\\\\\") < 0) {\r\n        return str;\r\n    }\r\n\r\n    return str.replace(UNESCAPE_MD_RE, \"$1\");\r\n}","startLine":47,"endLine":50,"nodeType":"FunctionDeclaration"},{"functionBody":"function isValidEntityCode(c) {\r\n    if (c >= 0xD800 && c <= 0xDFFF) {\r\n        return false;\r\n    }\r\n\r\n    if (c >= 0xFDD0 && c <= 0xFDEF) {\r\n        return false;\r\n    }\r\n\r\n    if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {\r\n        return false;\r\n    }\r\n\r\n    if (c >= 0x00 && c <= 0x08) {\r\n        return false;\r\n    }\r\n\r\n    if (c === 0x0B) {\r\n        return false;\r\n    }\r\n\r\n    if (c >= 0x0E && c <= 0x1F) {\r\n        return false;\r\n    }\r\n\r\n    if (c >= 0x7F && c <= 0x9F) {\r\n        return false;\r\n    }\r\n\r\n    if (c > 0x10FFFF) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}","startLine":54,"endLine":69,"nodeType":"FunctionDeclaration"},{"functionBody":"function fromCodePoint(c) {\r\n    if (c > 0xffff) {\r\n        c -= 0x10000;\r\n        var surrogate1 = 0xd800 + (c >> 10), surrogate2 = 0xdc00 + (c & 0x3ff);\r\n        return String.fromCharCode(surrogate1, surrogate2);\r\n    }\r\n\r\n    return String.fromCharCode(c);\r\n}","startLine":71,"endLine":81,"nodeType":"FunctionDeclaration"},{"functionBody":"function replaceEntityPattern(match, name) {\r\n    var code = 0;\r\n\r\n    if (has(entities, name)) {\r\n        return entities[name];\r\n    } else if (name.charCodeAt(0) === 0x23 && DIGITAL_ENTITY_TEST_RE.test(name)) {\r\n        code = name[1].toLowerCase() === \"x\" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);\r\n\r\n        if (isValidEntityCode(code)) {\r\n            return fromCodePoint(code);\r\n        }\r\n    }\r\n\r\n    return match;\r\n}","startLine":87,"endLine":102,"nodeType":"FunctionDeclaration"},{"functionBody":"function replaceEntities(str) {\r\n    if (str.indexOf(\"&\") < 0) {\r\n        return str;\r\n    }\r\n\r\n    return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);\r\n}","startLine":104,"endLine":108,"nodeType":"FunctionDeclaration"},{"functionBody":"function replaceUnsafeChar(ch) {\r\n    return HTML_REPLACEMENTS[ch];\r\n}","startLine":121,"endLine":123,"nodeType":"FunctionDeclaration"},{"functionBody":"function escapeHtml(str) {\r\n    if (HTML_ESCAPE_TEST_RE.test(str)) {\r\n        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\r\n    }\r\n\r\n    return str;\r\n}","startLine":125,"endLine":130,"nodeType":"FunctionDeclaration"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\configs\\commonmark.js","messages":[]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\configs\\default.js","messages":[]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\configs\\full.js","messages":[]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\helpers\\normalize_link.js","messages":[{"functionBody":"function normalizeLink(url) {\r\n    var normalized = replaceEntities(url);\r\n\r\n    try {\r\n        normalized = decodeURI(normalized);\r\n    } catch (err) {}\r\n\r\n    return encodeURI(normalized);\r\n}","startLine":5,"endLine":13,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\helpers\\normalize_reference.js","messages":[{"functionBody":"function normalizeReference(str) {\r\n    return str.trim().replace(/\\s+/g, \" \").toUpperCase();\r\n}","startLine":3,"endLine":8,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\helpers\\parse_link_destination.js","messages":[{"functionBody":"function parseLinkDestination(state, pos) {\r\n    var code, level, link, start = pos, max = state.posMax;\r\n\r\n    if (state.src.charCodeAt(pos) === 0x3C) {\r\n        pos++;\r\n\r\n        while (pos < max) {\r\n            code = state.src.charCodeAt(pos);\r\n\r\n            if (code === 0x0A) {\r\n                return false;\r\n            }\r\n\r\n            if (code === 0x3E) {\r\n                link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));\r\n\r\n                if (!state.parser.validateLink(link)) {\r\n                    return false;\r\n                }\r\n\r\n                state.pos = pos + 1;\r\n                state.linkContent = link;\r\n                return true;\r\n            }\r\n\r\n            if (code === 0x5C && pos + 1 < max) {\r\n                pos += 2;\r\n                continue;\r\n            }\r\n\r\n            pos++;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    level = 0;\r\n\r\n    while (pos < max) {\r\n        code = state.src.charCodeAt(pos);\r\n\r\n        if (code === 0x20) {\r\n            break;\r\n        }\r\n\r\n        if (code > 0x08 && code < 0x0e) {\r\n            break;\r\n        }\r\n\r\n        if (code === 0x5C && pos + 1 < max) {\r\n            pos += 2;\r\n            continue;\r\n        }\r\n\r\n        if (code === 0x28) {\r\n            level++;\r\n\r\n            if (level > 1) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (code === 0x29) {\r\n            level--;\r\n\r\n            if (level < 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        pos++;\r\n    }\r\n\r\n    if (start === pos) {\r\n        return false;\r\n    }\r\n\r\n    link = unescapeMd(state.src.slice(start, pos));\r\n\r\n    if (!state.parser.validateLink(link)) {\r\n        return false;\r\n    }\r\n\r\n    state.linkContent = link;\r\n    state.pos = pos;\r\n    return true;\r\n}","startLine":18,"endLine":83,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\helpers\\parse_link_label.js","messages":[{"functionBody":"function parseLinkLabel(state, start) {\r\n    var level, found, marker, labelEnd = -1, max = state.posMax, oldPos = state.pos, oldFlag = state.isInLabel;\r\n\r\n    if (state.isInLabel) {\r\n        return -1;\r\n    }\r\n\r\n    if (state.labelUnmatchedScopes) {\r\n        state.labelUnmatchedScopes--;\r\n        return -1;\r\n    }\r\n\r\n    state.pos = start + 1;\r\n    state.isInLabel = true;\r\n    level = 1;\r\n\r\n    while (state.pos < max) {\r\n        marker = state.src.charCodeAt(state.pos);\r\n\r\n        if (marker === 0x5B) {\r\n            level++;\r\n        } else if (marker === 0x5D) {\r\n            level--;\r\n\r\n            if (level === 0) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        state.parser.skipToken(state);\r\n    }\r\n\r\n    if (found) {\r\n        labelEnd = state.pos;\r\n        state.labelUnmatchedScopes = 0;\r\n    } else {\r\n        state.labelUnmatchedScopes = level - 1;\r\n    }\r\n\r\n    state.pos = oldPos;\r\n    state.isInLabel = oldFlag;\r\n    return labelEnd;\r\n}","startLine":14,"endLine":59,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\helpers\\parse_link_title.js","messages":[{"functionBody":"function parseLinkTitle(state, pos) {\r\n    var code, start = pos, max = state.posMax, marker = state.src.charCodeAt(pos);\r\n\r\n    if (marker !== 0x22 && marker !== 0x27 && marker !== 0x28) {\r\n        return false;\r\n    }\r\n\r\n    pos++;\r\n\r\n    if (marker === 0x28) {\r\n        marker = 0x29;\r\n    }\r\n\r\n    while (pos < max) {\r\n        code = state.src.charCodeAt(pos);\r\n\r\n        if (code === marker) {\r\n            state.pos = pos + 1;\r\n            state.linkContent = unescapeMd(state.src.slice(start + 1, pos));\r\n            return true;\r\n        }\r\n\r\n        if (code === 0x5C && pos + 1 < max) {\r\n            pos += 2;\r\n            continue;\r\n        }\r\n\r\n        pos++;\r\n    }\r\n\r\n    return false;\r\n}","startLine":17,"endLine":46,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\index.js","messages":[{"functionBody":"function StateCore(instance, str, env) {\r\n    this.src = str;\r\n    this.env = env;\r\n    this.options = instance.options;\r\n    this.tokens = [];\r\n    this.inlineMode = false;\r\n    this.inline = instance.inline;\r\n    this.block = instance.block;\r\n    this.renderer = instance.renderer;\r\n    this.typographer = instance.typographer;\r\n}","startLine":32,"endLine":43,"nodeType":"FunctionDeclaration"},{"functionBody":"function Remarkable(preset, options) {\r\n    if (typeof preset !== \"string\") {\r\n        options = preset;\r\n        preset = \"default\";\r\n    }\r\n\r\n    this.inline = new ParserInline();\r\n    this.block = new ParserBlock();\r\n    this.core = new ParserCore();\r\n    this.renderer = new Renderer();\r\n    this.ruler = new Ruler();\r\n    this.options = {};\r\n    this.configure(config[preset]);\r\n    this.set(options || {});\r\n}","startLine":53,"endLine":68,"nodeType":"FunctionDeclaration"},{"functionBody":"function(options) {\r\n    assign(this.options, options);\r\n}","startLine":81,"endLine":83,"nodeType":"FunctionExpression"},{"functionBody":"function(presets) {\r\n    var self = this;\r\n\r\n    if (!presets) {\r\n        throw new Error(\"Wrong `remarkable` preset, check name/content\");\r\n    }\r\n\r\n    if (presets.options) {\r\n        self.set(presets.options);\r\n    }\r\n\r\n    if (presets.components) {\r\n        Object.keys(presets.components).forEach(function(name) {\r\n            if (presets.components[name].rules) {\r\n                self[name].ruler.enable(presets.components[name].rules, true);\r\n            }\r\n        });\r\n    }\r\n}","startLine":91,"endLine":103,"nodeType":"FunctionExpression"},{"functionBody":"function(name) {\r\n    if (presets.components[name].rules) {\r\n        self[name].ruler.enable(presets.components[name].rules, true);\r\n    }\r\n}","startLine":97,"endLine":101,"nodeType":"FunctionExpression"},{"functionBody":"function(plugin, options) {\r\n    plugin(this, options);\r\n    return this;\r\n}","startLine":121,"endLine":124,"nodeType":"FunctionExpression"},{"functionBody":"function(str, env) {\r\n    var state = new StateCore(this, str, env);\r\n    this.core.process(state);\r\n    return state.tokens;\r\n}","startLine":136,"endLine":140,"nodeType":"FunctionExpression"},{"functionBody":"function(str, env) {\r\n    env = env || {};\r\n    return this.renderer.render(this.parse(str, env), this.options, env);\r\n}","startLine":150,"endLine":153,"nodeType":"FunctionExpression"},{"functionBody":"function(str, env) {\r\n    var state = new StateCore(this, str, env);\r\n    state.inlineMode = true;\r\n    this.core.process(state);\r\n    return state.tokens;\r\n}","startLine":163,"endLine":168,"nodeType":"FunctionExpression"},{"functionBody":"function(str, env) {\r\n    env = env || {};\r\n    return this.renderer.render(this.parseInline(str, env), this.options, env);\r\n}","startLine":179,"endLine":182,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\parser_block.js","messages":[{"functionBody":"function ParserBlock() {\r\n    this.ruler = new Ruler();\r\n\r\n    for (var i = 0; i < _rules.length; i++) {\r\n        this.ruler.push(_rules[i][0], _rules[i][1], {\r\n            alt: (_rules[i][2] || []).slice()\r\n        });\r\n    }\r\n}","startLine":35,"endLine":42,"nodeType":"FunctionDeclaration"},{"functionBody":"function(state, startLine, endLine) {\r\n    var rules = this.ruler.getRules(\"\");\r\n    var len = rules.length;\r\n    var line = startLine;\r\n    var hasEmptyLines = false;\r\n    var ok, i;\r\n\r\n    while (line < endLine) {\r\n        state.line = line = state.skipEmptyLines(line);\r\n\r\n        if (line >= endLine) {\r\n            break;\r\n        }\r\n\r\n        if (state.tShift[line] < state.blkIndent) {\r\n            break;\r\n        }\r\n\r\n        for (i = 0; i < len; i++) {\r\n            ok = rules[i](state, line, endLine, false);\r\n\r\n            if (ok) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        state.tight = !hasEmptyLines;\r\n\r\n        if (state.isEmpty(state.line - 1)) {\r\n            hasEmptyLines = true;\r\n        }\r\n\r\n        line = state.line;\r\n\r\n        if (line < endLine && state.isEmpty(line)) {\r\n            hasEmptyLines = true;\r\n            line++;\r\n\r\n            if (line < endLine && state.parentType === \"list\" && state.isEmpty(line)) {\r\n                break;\r\n            }\r\n\r\n            state.line = line;\r\n        }\r\n    }\r\n}","startLine":53,"endLine":106,"nodeType":"FunctionExpression"},{"functionBody":"function(str, options, env, outTokens) {\r\n    var state, lineStart = 0, lastTabPos = 0;\r\n\r\n    if (!str) {\r\n        return [];\r\n    }\r\n\r\n    str = str.replace(SPACES_RE, \" \");\r\n    str = str.replace(NEWLINES_RE, \"\\n\");\r\n\r\n    if (str.indexOf(\"\\t\") >= 0) {\r\n        str = str.replace(TABS_SCAN_RE, function(match, offset) {\r\n            var result;\r\n\r\n            if (str.charCodeAt(offset) === 0x0A) {\r\n                lineStart = offset + 1;\r\n                lastTabPos = 0;\r\n                return match;\r\n            }\r\n\r\n            result = \"    \".slice((offset - lineStart - lastTabPos) % 4);\r\n            lastTabPos = offset - lineStart + 1;\r\n            return result;\r\n        });\r\n    }\r\n\r\n    state = new StateBlock(str, this, options, env, outTokens);\r\n    this.tokenize(state, state.line, state.lineMax);\r\n}","startLine":122,"endLine":149,"nodeType":"FunctionExpression"},{"functionBody":"function(match, offset) {\r\n    var result;\r\n\r\n    if (str.charCodeAt(offset) === 0x0A) {\r\n        lineStart = offset + 1;\r\n        lastTabPos = 0;\r\n        return match;\r\n    }\r\n\r\n    result = \"    \".slice((offset - lineStart - lastTabPos) % 4);\r\n    lastTabPos = offset - lineStart + 1;\r\n    return result;\r\n}","startLine":134,"endLine":144,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\parser_core.js","messages":[{"functionBody":"function Core() {\r\n    this.options = {};\r\n    this.ruler = new Ruler();\r\n\r\n    for (var i = 0; i < _rules.length; i++) {\r\n        this.ruler.push(_rules[i][0], _rules[i][1]);\r\n    }\r\n}","startLine":31,"endLine":37,"nodeType":"FunctionDeclaration"},{"functionBody":"function(state) {\r\n    var i, l, rules;\r\n    rules = this.ruler.getRules(\"\");\r\n\r\n    for (i = 0, l = rules.length; i < l; i++) {\r\n        rules[i](state);\r\n    }\r\n}","startLine":46,"endLine":52,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\parser_inline.js","messages":[{"functionBody":"function ParserInline() {\r\n    this.ruler = new Ruler();\r\n\r\n    for (var i = 0; i < _rules.length; i++) {\r\n        this.ruler.push(_rules[i][0], _rules[i][1]);\r\n    }\r\n\r\n    this.validateLink = validateLink;\r\n}","startLine":42,"endLine":50,"nodeType":"FunctionDeclaration"},{"functionBody":"function(state) {\r\n    var rules = this.ruler.getRules(\"\");\r\n    var len = rules.length;\r\n    var pos = state.pos;\r\n    var i, cached_pos;\r\n\r\n    if ((cached_pos = state.cacheGet(pos)) > 0) {\r\n        state.pos = cached_pos;\r\n        return;\r\n    }\r\n\r\n    for (i = 0; i < len; i++) {\r\n        if (rules[i](state, true)) {\r\n            state.cacheSet(pos, state.pos);\r\n            return;\r\n        }\r\n    }\r\n\r\n    state.pos++;\r\n    state.cacheSet(pos, state.pos);\r\n}","startLine":60,"endLine":80,"nodeType":"FunctionExpression"},{"functionBody":"function(state) {\r\n    var rules = this.ruler.getRules(\"\");\r\n    var len = rules.length;\r\n    var end = state.posMax;\r\n    var ok, i;\r\n\r\n    while (state.pos < end) {\r\n        for (i = 0; i < len; i++) {\r\n            ok = rules[i](state, false);\r\n\r\n            if (ok) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (ok) {\r\n            if (state.pos >= end) {\r\n                break;\r\n            }\r\n\r\n            continue;\r\n        }\r\n\r\n        state.pending += state.src[state.pos++];\r\n    }\r\n\r\n    if (state.pending) {\r\n        state.pushPending();\r\n    }\r\n}","startLine":89,"endLine":122,"nodeType":"FunctionExpression"},{"functionBody":"function(str, options, env, outTokens) {\r\n    var state = new StateInline(str, this, options, env, outTokens);\r\n    this.tokenize(state);\r\n}","startLine":134,"endLine":137,"nodeType":"FunctionExpression"},{"functionBody":"function validateLink(url) {\r\n    var BAD_PROTOCOLS = [\"vbscript\", \"javascript\", \"file\", \"data\"];\r\n    var str = url.trim().toLowerCase();\r\n    str = utils.replaceEntities(str);\r\n\r\n    if (str.indexOf(\":\") !== -1 && BAD_PROTOCOLS.indexOf(str.split(\":\")[0]) !== -1) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}","startLine":146,"endLine":155,"nodeType":"FunctionDeclaration"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\renderer.js","messages":[{"functionBody":"function Renderer() {\r\n    this.rules = utils.assign({}, rules);\r\n    this.getBreak = rules.getBreak;\r\n}","startLine":21,"endLine":26,"nodeType":"FunctionDeclaration"},{"functionBody":"function(tokens, options, env) {\r\n    var _rules = this.rules;\r\n    var len = tokens.length, i = 0;\r\n    var result = \"\";\r\n\r\n    while (len--) {\r\n        result += _rules[tokens[i].type](tokens, i++, options, env, this);\r\n    }\r\n\r\n    return result;\r\n}","startLine":39,"endLine":49,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, options, env) {\r\n    var _rules = this.rules;\r\n    var len = tokens.length, i = -1;\r\n    var result = \"\";\r\n\r\n    while (++i < len) {\r\n        if (tokens[i].type === \"inline\") {\r\n            result += this.renderInline(tokens[i].children, options, env);\r\n        } else {\r\n            result += _rules[tokens[i].type](tokens, i, options, env, this);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}","startLine":62,"endLine":75,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\ruler.js","messages":[{"functionBody":"function Ruler() {\r\n    this.__rules__ = [];\r\n    this.__cache__ = null;\r\n}","startLine":14,"endLine":30,"nodeType":"FunctionDeclaration"},{"functionBody":"function(name) {\r\n    var len = this.__rules__.length;\r\n    var i = -1;\r\n\r\n    while (len--) {\r\n        if (this.__rules__[++i].name === name) {\r\n            return i;\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}","startLine":40,"endLine":50,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    var self = this;\r\n    var chains = [\"\"];\r\n\r\n    self.__rules__.forEach(function(rule) {\r\n        if (!rule.enabled) {\r\n            return;\r\n        }\r\n\r\n        rule.alt.forEach(function(altName) {\r\n            if (chains.indexOf(altName) < 0) {\r\n                chains.push(altName);\r\n            }\r\n        });\r\n    });\r\n\r\n    self.__cache__ = {};\r\n\r\n    chains.forEach(function(chain) {\r\n        self.__cache__[chain] = [];\r\n\r\n        self.__rules__.forEach(function(rule) {\r\n            if (!rule.enabled) {\r\n                return;\r\n            }\r\n\r\n            if (chain && rule.alt.indexOf(chain) < 0) {\r\n                return;\r\n            }\r\n\r\n            self.__cache__[chain].push(rule.fn);\r\n        });\r\n    });\r\n}","startLine":58,"endLine":90,"nodeType":"FunctionExpression"},{"functionBody":"function(rule) {\r\n    if (!rule.enabled) {\r\n        return;\r\n    }\r\n\r\n    rule.alt.forEach(function(altName) {\r\n        if (chains.indexOf(altName) < 0) {\r\n            chains.push(altName);\r\n        }\r\n    });\r\n}","startLine":63,"endLine":73,"nodeType":"FunctionExpression"},{"functionBody":"function(altName) {\r\n    if (chains.indexOf(altName) < 0) {\r\n        chains.push(altName);\r\n    }\r\n}","startLine":68,"endLine":72,"nodeType":"FunctionExpression"},{"functionBody":"function(chain) {\r\n    self.__cache__[chain] = [];\r\n\r\n    self.__rules__.forEach(function(rule) {\r\n        if (!rule.enabled) {\r\n            return;\r\n        }\r\n\r\n        if (chain && rule.alt.indexOf(chain) < 0) {\r\n            return;\r\n        }\r\n\r\n        self.__cache__[chain].push(rule.fn);\r\n    });\r\n}","startLine":77,"endLine":89,"nodeType":"FunctionExpression"},{"functionBody":"function(rule) {\r\n    if (!rule.enabled) {\r\n        return;\r\n    }\r\n\r\n    if (chain && rule.alt.indexOf(chain) < 0) {\r\n        return;\r\n    }\r\n\r\n    self.__cache__[chain].push(rule.fn);\r\n}","startLine":79,"endLine":88,"nodeType":"FunctionExpression"},{"functionBody":"function(name, fn, options) {\r\n    var idx = this.__find__(name);\r\n    var opt = options || {};\r\n\r\n    if (idx === -1) {\r\n        throw new Error(\"Parser rule not found: \" + name);\r\n    }\r\n\r\n    this.__rules__[idx].fn = fn;\r\n    this.__rules__[idx].alt = opt.alt || [];\r\n    this.__cache__ = null;\r\n}","startLine":106,"endLine":117,"nodeType":"FunctionExpression"},{"functionBody":"function(beforeName, ruleName, fn, options) {\r\n    var idx = this.__find__(beforeName);\r\n    var opt = options || {};\r\n\r\n    if (idx === -1) {\r\n        throw new Error(\"Parser rule not found: \" + beforeName);\r\n    }\r\n\r\n    this.__rules__.splice(idx, 0, {\r\n        name: ruleName,\r\n        enabled: true,\r\n        fn: fn,\r\n        alt: opt.alt || []\r\n    });\r\n\r\n    this.__cache__ = null;\r\n}","startLine":129,"endLine":145,"nodeType":"FunctionExpression"},{"functionBody":"function(afterName, ruleName, fn, options) {\r\n    var idx = this.__find__(afterName);\r\n    var opt = options || {};\r\n\r\n    if (idx === -1) {\r\n        throw new Error(\"Parser rule not found: \" + afterName);\r\n    }\r\n\r\n    this.__rules__.splice(idx + 1, 0, {\r\n        name: ruleName,\r\n        enabled: true,\r\n        fn: fn,\r\n        alt: opt.alt || []\r\n    });\r\n\r\n    this.__cache__ = null;\r\n}","startLine":157,"endLine":173,"nodeType":"FunctionExpression"},{"functionBody":"function(ruleName, fn, options) {\r\n    var opt = options || {};\r\n\r\n    this.__rules__.push({\r\n        name: ruleName,\r\n        enabled: true,\r\n        fn: fn,\r\n        alt: opt.alt || []\r\n    });\r\n\r\n    this.__cache__ = null;\r\n}","startLine":184,"endLine":195,"nodeType":"FunctionExpression"},{"functionBody":"function(list, strict) {\r\n    list = !Array.isArray(list) ? [list] : list;\r\n\r\n    if (strict) {\r\n        this.__rules__.forEach(function(rule) {\r\n            rule.enabled = false;\r\n        });\r\n    }\r\n\r\n    list.forEach(function(name) {\r\n        var idx = this.__find__(name);\r\n\r\n        if (idx < 0) {\r\n            throw new Error(\"Rules manager: invalid rule name \" + name);\r\n        }\r\n\r\n        this.__rules__[idx].enabled = true;\r\n    }, this);\r\n\r\n    this.__cache__ = null;\r\n}","startLine":205,"endLine":227,"nodeType":"FunctionExpression"},{"functionBody":"function(rule) {\r\n    rule.enabled = false;\r\n}","startLine":212,"endLine":214,"nodeType":"FunctionExpression"},{"functionBody":"function(name) {\r\n    var idx = this.__find__(name);\r\n\r\n    if (idx < 0) {\r\n        throw new Error(\"Rules manager: invalid rule name \" + name);\r\n    }\r\n\r\n    this.__rules__[idx].enabled = true;\r\n}","startLine":218,"endLine":224,"nodeType":"FunctionExpression"},{"functionBody":"function(list) {\r\n    list = !Array.isArray(list) ? [list] : list;\r\n\r\n    list.forEach(function(name) {\r\n        var idx = this.__find__(name);\r\n\r\n        if (idx < 0) {\r\n            throw new Error(\"Rules manager: invalid rule name \" + name);\r\n        }\r\n\r\n        this.__rules__[idx].enabled = false;\r\n    }, this);\r\n\r\n    this.__cache__ = null;\r\n}","startLine":237,"endLine":252,"nodeType":"FunctionExpression"},{"functionBody":"function(name) {\r\n    var idx = this.__find__(name);\r\n\r\n    if (idx < 0) {\r\n        throw new Error(\"Rules manager: invalid rule name \" + name);\r\n    }\r\n\r\n    this.__rules__[idx].enabled = false;\r\n}","startLine":243,"endLine":249,"nodeType":"FunctionExpression"},{"functionBody":"function(chainName) {\r\n    if (this.__cache__ === null) {\r\n        this.__compile__();\r\n    }\r\n\r\n    return this.__cache__[chainName] || [];\r\n}","startLine":262,"endLine":267,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules.js","messages":[{"functionBody":"function() {\r\n    return \"<blockquote>\\n\";\r\n}","startLine":22,"endLine":24,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    return \"</blockquote>\" + getBreak(tokens, idx);\r\n}","startLine":26,"endLine":28,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    if (tokens[idx].block) {\r\n        return \"<pre><code>\" + escapeHtml(tokens[idx].content) + \"</code></pre>\" + getBreak(tokens, idx);\r\n    }\r\n\r\n    return \"<code>\" + escapeHtml(tokens[idx].content) + \"</code>\";\r\n}","startLine":34,"endLine":39,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx, options, env, instance) {\r\n    var token = tokens[idx];\r\n    var langClass = \"\";\r\n    var langPrefix = options.langPrefix;\r\n    var langName = \"\", fences, fenceName;\r\n    var highlighted;\r\n\r\n    if (token.params) {\r\n        fences = token.params.split(/\\s+/g);\r\n        fenceName = fences.join(\" \");\r\n\r\n        if (has(instance.rules.fence_custom, fences[0])) {\r\n            return instance.rules.fence_custom[fences[0]](tokens, idx, options, env, instance);\r\n        }\r\n\r\n        langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));\r\n        langClass = \" class=\\\"\" + langPrefix + langName + \"\\\"\";\r\n    }\r\n\r\n    if (options.highlight) {\r\n        highlighted = options.highlight.apply(options.highlight, [token.content].concat(fences)) || escapeHtml(token.content);\r\n    } else {\r\n        highlighted = escapeHtml(token.content);\r\n    }\r\n\r\n    return \"<pre><code\" + langClass + \">\" + highlighted + \"</code></pre>\" + getBreak(tokens, idx);\r\n}","startLine":45,"endLine":83,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    return \"<h\" + tokens[idx].hLevel + \">\";\r\n}","startLine":91,"endLine":93,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    return \"</h\" + tokens[idx].hLevel + \">\\n\";\r\n}","startLine":94,"endLine":96,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx, options) {\r\n    return (options.xhtmlOut ? \"<hr />\" : \"<hr>\") + getBreak(tokens, idx);\r\n}","startLine":102,"endLine":104,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<ul>\\n\";\r\n}","startLine":110,"endLine":112,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    return \"</ul>\" + getBreak(tokens, idx);\r\n}","startLine":113,"endLine":115,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<li>\";\r\n}","startLine":121,"endLine":123,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</li>\\n\";\r\n}","startLine":124,"endLine":126,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    var token = tokens[idx];\r\n    var order = token.order > 1 ? \" start=\\\"\" + token.order + \"\\\"\" : \"\";\r\n    return \"<ol\" + order + \">\\n\";\r\n}","startLine":132,"endLine":136,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    return \"</ol>\" + getBreak(tokens, idx);\r\n}","startLine":137,"endLine":139,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    return tokens[idx].tight ? \"\" : \"<p>\";\r\n}","startLine":145,"endLine":147,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === \"inline\" && !tokens[idx - 1].content);\r\n    return (tokens[idx].tight ? \"\" : \"</p>\") + (addBreak ? getBreak(tokens, idx) : \"\");\r\n}","startLine":148,"endLine":151,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx, options) {\r\n    var title = tokens[idx].title ? \" title=\\\"\" + escapeHtml(replaceEntities(tokens[idx].title)) + \"\\\"\" : \"\";\r\n    var target = options.linkTarget ? \" target=\\\"\" + options.linkTarget + \"\\\"\" : \"\";\r\n    return \"<a href=\\\"\" + escapeHtml(tokens[idx].href) + \"\\\"\" + title + target + \">\";\r\n}","startLine":157,"endLine":161,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</a>\";\r\n}","startLine":162,"endLine":164,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx, options) {\r\n    var src = \" src=\\\"\" + escapeHtml(tokens[idx].src) + \"\\\"\";\r\n    var title = tokens[idx].title ? \" title=\\\"\" + escapeHtml(replaceEntities(tokens[idx].title)) + \"\\\"\" : \"\";\r\n    var alt = \" alt=\\\"\" + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : \"\") + \"\\\"\";\r\n    var suffix = options.xhtmlOut ? \" /\" : \"\";\r\n    return \"<img\" + src + alt + title + suffix + \">\";\r\n}","startLine":170,"endLine":176,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<table>\\n\";\r\n}","startLine":182,"endLine":184,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</table>\\n\";\r\n}","startLine":185,"endLine":187,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<thead>\\n\";\r\n}","startLine":188,"endLine":190,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</thead>\\n\";\r\n}","startLine":191,"endLine":193,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<tbody>\\n\";\r\n}","startLine":194,"endLine":196,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</tbody>\\n\";\r\n}","startLine":197,"endLine":199,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<tr>\";\r\n}","startLine":200,"endLine":202,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</tr>\\n\";\r\n}","startLine":203,"endLine":205,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    var token = tokens[idx];\r\n    return \"<th\" + (token.align ? \" style=\\\"text-align:\" + token.align + \"\\\"\" : \"\") + \">\";\r\n}","startLine":206,"endLine":211,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</th>\";\r\n}","startLine":212,"endLine":214,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    var token = tokens[idx];\r\n    return \"<td\" + (token.align ? \" style=\\\"text-align:\" + token.align + \"\\\"\" : \"\") + \">\";\r\n}","startLine":215,"endLine":220,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</td>\";\r\n}","startLine":221,"endLine":223,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<strong>\";\r\n}","startLine":229,"endLine":231,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</strong>\";\r\n}","startLine":232,"endLine":234,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<em>\";\r\n}","startLine":240,"endLine":242,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</em>\";\r\n}","startLine":243,"endLine":245,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<del>\";\r\n}","startLine":251,"endLine":253,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</del>\";\r\n}","startLine":254,"endLine":256,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<ins>\";\r\n}","startLine":262,"endLine":264,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</ins>\";\r\n}","startLine":265,"endLine":267,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<mark>\";\r\n}","startLine":273,"endLine":275,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</mark>\";\r\n}","startLine":276,"endLine":278,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    return \"<sub>\" + escapeHtml(tokens[idx].content) + \"</sub>\";\r\n}","startLine":284,"endLine":286,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    return \"<sup>\" + escapeHtml(tokens[idx].content) + \"</sup>\";\r\n}","startLine":287,"endLine":289,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx, options) {\r\n    return options.xhtmlOut ? \"<br />\\n\" : \"<br>\\n\";\r\n}","startLine":295,"endLine":297,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx, options) {\r\n    return options.breaks ? options.xhtmlOut ? \"<br />\\n\" : \"<br>\\n\" : \"\\n\";\r\n}","startLine":298,"endLine":300,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    return escapeHtml(tokens[idx].content);\r\n}","startLine":306,"endLine":308,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    return tokens[idx].content;\r\n}","startLine":314,"endLine":316,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    return tokens[idx].content;\r\n}","startLine":317,"endLine":319,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    return \"<abbr title=\\\"\" + escapeHtml(replaceEntities(tokens[idx].title)) + \"\\\">\";\r\n}","startLine":325,"endLine":327,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</abbr>\";\r\n}","startLine":328,"endLine":330,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    var n = Number(tokens[idx].id + 1).toString();\r\n    var id = \"fnref\" + n;\r\n\r\n    if (tokens[idx].subId > 0) {\r\n        id += \":\" + tokens[idx].subId;\r\n    }\r\n\r\n    return \"<sup class=\\\"footnote-ref\\\"><a href=\\\"#fn\" + n + \"\\\" id=\\\"\" + id + \"\\\">[\" + n + \"]</a></sup>\";\r\n}","startLine":336,"endLine":343,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx, options) {\r\n    var hr = options.xhtmlOut ? \"<hr class=\\\"footnotes-sep\\\" />\\n\" : \"<hr class=\\\"footnotes-sep\\\">\\n\";\r\n    return hr + \"<section class=\\\"footnotes\\\">\\n<ol class=\\\"footnotes-list\\\">\\n\";\r\n}","startLine":344,"endLine":349,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</ol>\\n</section>\\n\";\r\n}","startLine":350,"endLine":352,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    var id = Number(tokens[idx].id + 1).toString();\r\n    return \"<li id=\\\"fn\" + id + \"\\\"  class=\\\"footnote-item\\\">\";\r\n}","startLine":353,"endLine":356,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</li>\\n\";\r\n}","startLine":357,"endLine":359,"nodeType":"FunctionExpression"},{"functionBody":"function(tokens, idx) {\r\n    var n = Number(tokens[idx].id + 1).toString();\r\n    var id = \"fnref\" + n;\r\n\r\n    if (tokens[idx].subId > 0) {\r\n        id += \":\" + tokens[idx].subId;\r\n    }\r\n\r\n    return \" <a href=\\\"#\" + id + \"\\\" class=\\\"footnote-backref\\\">â†©</a>\";\r\n}","startLine":360,"endLine":367,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<dl>\\n\";\r\n}","startLine":373,"endLine":375,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<dt>\";\r\n}","startLine":376,"endLine":378,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"<dd>\";\r\n}","startLine":379,"endLine":381,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</dl>\\n\";\r\n}","startLine":382,"endLine":384,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</dt>\\n\";\r\n}","startLine":385,"endLine":387,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return \"</dd>\\n\";\r\n}","startLine":388,"endLine":390,"nodeType":"FunctionExpression"},{"functionBody":"function nextToken(tokens, idx) {\r\n    if (++idx >= tokens.length - 2) {\r\n        return idx;\r\n    }\r\n\r\n    if (tokens[idx].type === \"paragraph_open\" && tokens[idx].tight && (tokens[idx + 1].type === \"inline\" && tokens[idx + 1].content.length === 0) && (tokens[idx + 2].type === \"paragraph_close\" && tokens[idx + 2].tight)) {\r\n        return nextToken(tokens, idx + 2);\r\n    }\r\n\r\n    return idx;\r\n}","startLine":396,"endLine":406,"nodeType":"FunctionDeclaration"},{"functionBody":"function getBreak(tokens, idx) {\r\n    idx = nextToken(tokens, idx);\r\n\r\n    if (idx < tokens.length && tokens[idx].type === \"list_item_close\") {\r\n        return \"\";\r\n    }\r\n\r\n    return \"\\n\";\r\n}","startLine":417,"endLine":423,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\blockquote.js","messages":[{"functionBody":"function blockquote(state, startLine, endLine, silent) {\r\n    var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines, terminatorRules, i, l, terminate, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\r\n\r\n    if (pos > max) {\r\n        return false;\r\n    }\r\n\r\n    if (state.src.charCodeAt(pos++) !== 0x3E) {\r\n        return false;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    if (silent) {\r\n        return true;\r\n    }\r\n\r\n    if (state.src.charCodeAt(pos) === 0x20) {\r\n        pos++;\r\n    }\r\n\r\n    oldIndent = state.blkIndent;\r\n    state.blkIndent = 0;\r\n    oldBMarks = [state.bMarks[startLine]];\r\n    state.bMarks[startLine] = pos;\r\n    pos = pos < max ? state.skipSpaces(pos) : pos;\r\n    lastLineEmpty = pos >= max;\r\n    oldTShift = [state.tShift[startLine]];\r\n    state.tShift[startLine] = pos - state.bMarks[startLine];\r\n    terminatorRules = state.parser.ruler.getRules(\"blockquote\");\r\n\r\n    for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\r\n        pos = state.bMarks[nextLine] + state.tShift[nextLine];\r\n        max = state.eMarks[nextLine];\r\n\r\n        if (pos >= max) {\r\n            break;\r\n        }\r\n\r\n        if (state.src.charCodeAt(pos++) === 0x3E) {\r\n            if (state.src.charCodeAt(pos) === 0x20) {\r\n                pos++;\r\n            }\r\n\r\n            oldBMarks.push(state.bMarks[nextLine]);\r\n            state.bMarks[nextLine] = pos;\r\n            pos = pos < max ? state.skipSpaces(pos) : pos;\r\n            lastLineEmpty = pos >= max;\r\n            oldTShift.push(state.tShift[nextLine]);\r\n            state.tShift[nextLine] = pos - state.bMarks[nextLine];\r\n            continue;\r\n        }\r\n\r\n        if (lastLineEmpty) {\r\n            break;\r\n        }\r\n\r\n        terminate = false;\r\n\r\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\r\n            if (terminatorRules[i](state, nextLine, endLine, true)) {\r\n                terminate = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (terminate) {\r\n            break;\r\n        }\r\n\r\n        oldBMarks.push(state.bMarks[nextLine]);\r\n        oldTShift.push(state.tShift[nextLine]);\r\n        state.tShift[nextLine] = -1337;\r\n    }\r\n\r\n    oldParentType = state.parentType;\r\n    state.parentType = \"blockquote\";\r\n\r\n    state.tokens.push({\r\n        type: \"blockquote_open\",\r\n        lines: lines = [startLine, 0],\r\n        level: state.level++\r\n    });\r\n\r\n    state.parser.tokenize(state, startLine, nextLine);\r\n\r\n    state.tokens.push({\r\n        type: \"blockquote_close\",\r\n        level: --state.level\r\n    });\r\n\r\n    state.parentType = oldParentType;\r\n    lines[1] = state.line;\r\n\r\n    for (i = 0; i < oldTShift.length; i++) {\r\n        state.bMarks[i + startLine] = oldBMarks[i];\r\n        state.tShift[i + startLine] = oldTShift[i];\r\n    }\r\n\r\n    state.blkIndent = oldIndent;\r\n    return true;\r\n}","startLine":6,"endLine":133,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\code.js","messages":[{"functionBody":"function code(state, startLine, endLine) {\r\n    var nextLine, last;\r\n\r\n    if (state.tShift[startLine] - state.blkIndent < 4) {\r\n        return false;\r\n    }\r\n\r\n    last = nextLine = startLine + 1;\r\n\r\n    while (nextLine < endLine) {\r\n        if (state.isEmpty(nextLine)) {\r\n            nextLine++;\r\n            continue;\r\n        }\r\n\r\n        if (state.tShift[nextLine] - state.blkIndent >= 4) {\r\n            nextLine++;\r\n            last = nextLine;\r\n            continue;\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    state.line = nextLine;\r\n\r\n    state.tokens.push({\r\n        type: \"code\",\r\n        content: state.getLines(startLine, last, 4 + state.blkIndent, true),\r\n        block: true,\r\n        lines: [startLine, state.line],\r\n        level: state.level\r\n    });\r\n\r\n    return true;\r\n}","startLine":6,"endLine":36,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\deflist.js","messages":[{"functionBody":"function skipMarker(state, line) {\r\n    var pos, marker, start = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];\r\n\r\n    if (start >= max) {\r\n        return -1;\r\n    }\r\n\r\n    marker = state.src.charCodeAt(start++);\r\n\r\n    if (marker !== 0x7E && marker !== 0x3A) {\r\n        return -1;\r\n    }\r\n\r\n    pos = state.skipSpaces(start);\r\n\r\n    if (start === pos) {\r\n        return -1;\r\n    }\r\n\r\n    if (pos >= max) {\r\n        return -1;\r\n    }\r\n\r\n    return pos;\r\n}","startLine":8,"endLine":28,"nodeType":"FunctionDeclaration"},{"functionBody":"function markTightParagraphs(state, idx) {\r\n    var i, l, level = state.level + 2;\r\n\r\n    for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\r\n        if (state.tokens[i].level === level && state.tokens[i].type === \"paragraph_open\") {\r\n            state.tokens[i + 2].tight = true;\r\n            state.tokens[i].tight = true;\r\n            i += 2;\r\n        }\r\n    }\r\n}","startLine":30,"endLine":41,"nodeType":"FunctionDeclaration"},{"functionBody":"function deflist(state, startLine, endLine, silent) {\r\n    var contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, nextLine, oldIndent, oldDDIndent, oldParentType, oldTShift, oldTight, prevEmptyEnd, tight;\r\n\r\n    if (silent) {\r\n        if (state.ddIndent < 0) {\r\n            return false;\r\n        }\r\n\r\n        return skipMarker(state, startLine) >= 0;\r\n    }\r\n\r\n    nextLine = startLine + 1;\r\n\r\n    if (state.isEmpty(nextLine)) {\r\n        if (++nextLine > endLine) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    if (state.tShift[nextLine] < state.blkIndent) {\r\n        return false;\r\n    }\r\n\r\n    contentStart = skipMarker(state, nextLine);\r\n\r\n    if (contentStart < 0) {\r\n        return false;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    listTokIdx = state.tokens.length;\r\n\r\n    state.tokens.push({\r\n        type: \"dl_open\",\r\n        lines: listLines = [startLine, 0],\r\n        level: state.level++\r\n    });\r\n\r\n    dtLine = startLine;\r\n    ddLine = nextLine;\r\n\r\n    OUTER:\r\n    for (; ; ) {\r\n        tight = true;\r\n        prevEmptyEnd = false;\r\n\r\n        state.tokens.push({\r\n            type: \"dt_open\",\r\n            lines: [dtLine, dtLine],\r\n            level: state.level++\r\n        });\r\n\r\n        state.tokens.push({\r\n            type: \"inline\",\r\n            content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\r\n            level: state.level + 1,\r\n            lines: [dtLine, dtLine],\r\n            children: []\r\n        });\r\n\r\n        state.tokens.push({\r\n            type: \"dt_close\",\r\n            level: --state.level\r\n        });\r\n\r\n        for (; ; ) {\r\n            state.tokens.push({\r\n                type: \"dd_open\",\r\n                lines: itemLines = [nextLine, 0],\r\n                level: state.level++\r\n            });\r\n\r\n            oldTight = state.tight;\r\n            oldDDIndent = state.ddIndent;\r\n            oldIndent = state.blkIndent;\r\n            oldTShift = state.tShift[ddLine];\r\n            oldParentType = state.parentType;\r\n            state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\r\n            state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\r\n            state.tight = true;\r\n            state.parentType = \"deflist\";\r\n            state.parser.tokenize(state, ddLine, endLine, true);\r\n\r\n            if (!state.tight || prevEmptyEnd) {\r\n                tight = false;\r\n            }\r\n\r\n            prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);\r\n            state.tShift[ddLine] = oldTShift;\r\n            state.tight = oldTight;\r\n            state.parentType = oldParentType;\r\n            state.blkIndent = oldIndent;\r\n            state.ddIndent = oldDDIndent;\r\n\r\n            state.tokens.push({\r\n                type: \"dd_close\",\r\n                level: --state.level\r\n            });\r\n\r\n            itemLines[1] = nextLine = state.line;\r\n\r\n            if (nextLine >= endLine) {\r\n                break OUTER;\r\n            }\r\n\r\n            if (state.tShift[nextLine] < state.blkIndent) {\r\n                break OUTER;\r\n            }\r\n\r\n            contentStart = skipMarker(state, nextLine);\r\n\r\n            if (contentStart < 0) {\r\n                break;\r\n            }\r\n\r\n            ddLine = nextLine;\r\n        }\r\n\r\n        if (nextLine >= endLine) {\r\n            break;\r\n        }\r\n\r\n        dtLine = nextLine;\r\n\r\n        if (state.isEmpty(dtLine)) {\r\n            break;\r\n        }\r\n\r\n        if (state.tShift[dtLine] < state.blkIndent) {\r\n            break;\r\n        }\r\n\r\n        ddLine = dtLine + 1;\r\n\r\n        if (ddLine >= endLine) {\r\n            break;\r\n        }\r\n\r\n        if (state.isEmpty(ddLine)) {\r\n            ddLine++;\r\n        }\r\n\r\n        if (ddLine >= endLine) {\r\n            break;\r\n        }\r\n\r\n        if (state.tShift[ddLine] < state.blkIndent) {\r\n            break;\r\n        }\r\n\r\n        contentStart = skipMarker(state, ddLine);\r\n\r\n        if (contentStart < 0) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    state.tokens.push({\r\n        type: \"dl_close\",\r\n        level: --state.level\r\n    });\r\n\r\n    listLines[1] = nextLine;\r\n    state.line = nextLine;\r\n\r\n    if (tight) {\r\n        markTightParagraphs(state, listTokIdx);\r\n    }\r\n\r\n    return true;\r\n}","startLine":43,"endLine":207,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\fences.js","messages":[{"functionBody":"function fences(state, startLine, endLine, silent) {\r\n    var marker, len, params, nextLine, mem, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\r\n\r\n    if (pos + 3 > max) {\r\n        return false;\r\n    }\r\n\r\n    marker = state.src.charCodeAt(pos);\r\n\r\n    if (marker !== 0x7E && marker !== 0x60) {\r\n        return false;\r\n    }\r\n\r\n    mem = pos;\r\n    pos = state.skipChars(pos, marker);\r\n    len = pos - mem;\r\n\r\n    if (len < 3) {\r\n        return false;\r\n    }\r\n\r\n    params = state.src.slice(pos, max).trim();\r\n\r\n    if (params.indexOf(\"`\") >= 0) {\r\n        return false;\r\n    }\r\n\r\n    if (silent) {\r\n        return true;\r\n    }\r\n\r\n    nextLine = startLine;\r\n\r\n    for (; ; ) {\r\n        nextLine++;\r\n\r\n        if (nextLine >= endLine) {\r\n            break;\r\n        }\r\n\r\n        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\r\n        max = state.eMarks[nextLine];\r\n\r\n        if (pos < max && state.tShift[nextLine] < state.blkIndent) {\r\n            break;\r\n        }\r\n\r\n        if (state.src.charCodeAt(pos) !== marker) {\r\n            continue;\r\n        }\r\n\r\n        if (state.tShift[nextLine] - state.blkIndent >= 4) {\r\n            continue;\r\n        }\r\n\r\n        pos = state.skipChars(pos, marker);\r\n\r\n        if (pos - mem < len) {\r\n            continue;\r\n        }\r\n\r\n        pos = state.skipSpaces(pos);\r\n\r\n        if (pos < max) {\r\n            continue;\r\n        }\r\n\r\n        haveEndMarker = true;\r\n        break;\r\n    }\r\n\r\n    len = state.tShift[startLine];\r\n    state.line = nextLine + (haveEndMarker ? 1 : 0);\r\n\r\n    state.tokens.push({\r\n        type: \"fence\",\r\n        params: params,\r\n        content: state.getLines(startLine + 1, nextLine, len, true),\r\n        lines: [startLine, state.line],\r\n        level: state.level\r\n    });\r\n\r\n    return true;\r\n}","startLine":6,"endLine":91,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\footnote.js","messages":[{"functionBody":"function footnote(state, startLine, endLine, silent) {\r\n    var oldBMark, oldTShift, oldParentType, pos, label, start = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\r\n\r\n    if (start + 4 > max) {\r\n        return false;\r\n    }\r\n\r\n    if (state.src.charCodeAt(start) !== 0x5B) {\r\n        return false;\r\n    }\r\n\r\n    if (state.src.charCodeAt(start + 1) !== 0x5E) {\r\n        return false;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    for (pos = start + 2; pos < max; pos++) {\r\n        if (state.src.charCodeAt(pos) === 0x20) {\r\n            return false;\r\n        }\r\n\r\n        if (state.src.charCodeAt(pos) === 0x5D) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (pos === start + 2) {\r\n        return false;\r\n    }\r\n\r\n    if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A) {\r\n        return false;\r\n    }\r\n\r\n    if (silent) {\r\n        return true;\r\n    }\r\n\r\n    pos++;\r\n\r\n    if (!state.env.footnotes) {\r\n        state.env.footnotes = {};\r\n    }\r\n\r\n    if (!state.env.footnotes.refs) {\r\n        state.env.footnotes.refs = {};\r\n    }\r\n\r\n    label = state.src.slice(start + 2, pos - 2);\r\n    state.env.footnotes.refs[\":\" + label] = -1;\r\n\r\n    state.tokens.push({\r\n        type: \"footnote_reference_open\",\r\n        label: label,\r\n        level: state.level++\r\n    });\r\n\r\n    oldBMark = state.bMarks[startLine];\r\n    oldTShift = state.tShift[startLine];\r\n    oldParentType = state.parentType;\r\n    state.tShift[startLine] = state.skipSpaces(pos) - pos;\r\n    state.bMarks[startLine] = pos;\r\n    state.blkIndent += 4;\r\n    state.parentType = \"footnote\";\r\n\r\n    if (state.tShift[startLine] < state.blkIndent) {\r\n        state.tShift[startLine] += state.blkIndent;\r\n        state.bMarks[startLine] -= state.blkIndent;\r\n    }\r\n\r\n    state.parser.tokenize(state, startLine, endLine, true);\r\n    state.parentType = oldParentType;\r\n    state.blkIndent -= 4;\r\n    state.tShift[startLine] = oldTShift;\r\n    state.bMarks[startLine] = oldBMark;\r\n\r\n    state.tokens.push({\r\n        type: \"footnote_reference_close\",\r\n        level: --state.level\r\n    });\r\n\r\n    return true;\r\n}","startLine":6,"endLine":67,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\heading.js","messages":[{"functionBody":"function heading(state, startLine, endLine, silent) {\r\n    var ch, level, tmp, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\r\n\r\n    if (pos >= max) {\r\n        return false;\r\n    }\r\n\r\n    ch = state.src.charCodeAt(pos);\r\n\r\n    if (ch !== 0x23 || pos >= max) {\r\n        return false;\r\n    }\r\n\r\n    level = 1;\r\n    ch = state.src.charCodeAt(++pos);\r\n\r\n    while (ch === 0x23 && pos < max && level <= 6) {\r\n        level++;\r\n        ch = state.src.charCodeAt(++pos);\r\n    }\r\n\r\n    if (level > 6 || pos < max && ch !== 0x20) {\r\n        return false;\r\n    }\r\n\r\n    if (silent) {\r\n        return true;\r\n    }\r\n\r\n    max = state.skipCharsBack(max, 0x20, pos);\r\n    tmp = state.skipCharsBack(max, 0x23, pos);\r\n\r\n    if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20) {\r\n        max = tmp;\r\n    }\r\n\r\n    state.line = startLine + 1;\r\n\r\n    state.tokens.push({\r\n        type: \"heading_open\",\r\n        hLevel: level,\r\n        lines: [startLine, state.line],\r\n        level: state.level\r\n    });\r\n\r\n    if (pos < max) {\r\n        state.tokens.push({\r\n            type: \"inline\",\r\n            content: state.src.slice(pos, max).trim(),\r\n            level: state.level + 1,\r\n            lines: [startLine, state.line],\r\n            children: []\r\n        });\r\n    }\r\n\r\n    state.tokens.push({\r\n        type: \"heading_close\",\r\n        hLevel: level,\r\n        level: state.level\r\n    });\r\n\r\n    return true;\r\n}","startLine":6,"endLine":58,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\hr.js","messages":[{"functionBody":"function hr(state, startLine, endLine, silent) {\r\n    var marker, cnt, ch, pos = state.bMarks[startLine], max = state.eMarks[startLine];\r\n    pos += state.tShift[startLine];\r\n\r\n    if (pos > max) {\r\n        return false;\r\n    }\r\n\r\n    marker = state.src.charCodeAt(pos++);\r\n\r\n    if (marker !== 0x2A && marker !== 0x2D && marker !== 0x5F) {\r\n        return false;\r\n    }\r\n\r\n    cnt = 1;\r\n\r\n    while (pos < max) {\r\n        ch = state.src.charCodeAt(pos++);\r\n\r\n        if (ch !== marker && ch !== 0x20) {\r\n            return false;\r\n        }\r\n\r\n        if (ch === marker) {\r\n            cnt++;\r\n        }\r\n    }\r\n\r\n    if (cnt < 3) {\r\n        return false;\r\n    }\r\n\r\n    if (silent) {\r\n        return true;\r\n    }\r\n\r\n    state.line = startLine + 1;\r\n\r\n    state.tokens.push({\r\n        type: \"hr\",\r\n        lines: [startLine, state.line],\r\n        level: state.level\r\n    });\r\n\r\n    return true;\r\n}","startLine":6,"endLine":45,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\htmlblock.js","messages":[{"functionBody":"function isLetter(ch) {\r\n    var lc = ch | 0x20;\r\n    return lc >= 0x61 && lc <= 0x7a;\r\n}","startLine":12,"endLine":16,"nodeType":"FunctionDeclaration"},{"functionBody":"function htmlblock(state, startLine, endLine, silent) {\r\n    var ch, match, nextLine, pos = state.bMarks[startLine], max = state.eMarks[startLine], shift = state.tShift[startLine];\r\n    pos += shift;\r\n\r\n    if (!state.options.html) {\r\n        return false;\r\n    }\r\n\r\n    if (shift > 3 || pos + 2 >= max) {\r\n        return false;\r\n    }\r\n\r\n    if (state.src.charCodeAt(pos) !== 0x3C) {\r\n        return false;\r\n    }\r\n\r\n    ch = state.src.charCodeAt(pos + 1);\r\n\r\n    if (ch === 0x21 || ch === 0x3F) {\r\n        if (silent) {\r\n            return true;\r\n        }\r\n    } else if (ch === 0x2F || isLetter(ch)) {\r\n        if (ch === 0x2F) {\r\n            match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);\r\n\r\n            if (!match) {\r\n                return false;\r\n            }\r\n        } else {\r\n            match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);\r\n\r\n            if (!match) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (block_names[match[1].toLowerCase()] !== true) {\r\n            return false;\r\n        }\r\n\r\n        if (silent) {\r\n            return true;\r\n        }\r\n    } else {\r\n        return false;\r\n    }\r\n\r\n    nextLine = startLine + 1;\r\n\r\n    while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {\r\n        nextLine++;\r\n    }\r\n\r\n    state.line = nextLine;\r\n\r\n    state.tokens.push({\r\n        type: \"htmlblock\",\r\n        level: state.level,\r\n        lines: [startLine, state.line],\r\n        content: state.getLines(startLine, nextLine, 0, true)\r\n    });\r\n\r\n    return true;\r\n}","startLine":18,"endLine":74,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\lheading.js","messages":[{"functionBody":"function lheading(state, startLine, endLine) {\r\n    var marker, pos, max, next = startLine + 1;\r\n\r\n    if (next >= endLine) {\r\n        return false;\r\n    }\r\n\r\n    if (state.tShift[next] < state.blkIndent) {\r\n        return false;\r\n    }\r\n\r\n    if (state.tShift[next] - state.blkIndent > 3) {\r\n        return false;\r\n    }\r\n\r\n    pos = state.bMarks[next] + state.tShift[next];\r\n    max = state.eMarks[next];\r\n\r\n    if (pos >= max) {\r\n        return false;\r\n    }\r\n\r\n    marker = state.src.charCodeAt(pos);\r\n\r\n    if (marker !== 0x2D && marker !== 0x3D) {\r\n        return false;\r\n    }\r\n\r\n    pos = state.skipChars(pos, marker);\r\n    pos = state.skipSpaces(pos);\r\n\r\n    if (pos < max) {\r\n        return false;\r\n    }\r\n\r\n    pos = state.bMarks[startLine] + state.tShift[startLine];\r\n    state.line = next + 1;\r\n\r\n    state.tokens.push({\r\n        type: \"heading_open\",\r\n        hLevel: marker === 0x3D ? 1 : 2,\r\n        lines: [startLine, state.line],\r\n        level: state.level\r\n    });\r\n\r\n    state.tokens.push({\r\n        type: \"inline\",\r\n        content: state.src.slice(pos, state.eMarks[startLine]).trim(),\r\n        level: state.level + 1,\r\n        lines: [startLine, state.line - 1],\r\n        children: []\r\n    });\r\n\r\n    state.tokens.push({\r\n        type: \"heading_close\",\r\n        hLevel: marker === 0x3D ? 1 : 2,\r\n        level: state.level\r\n    });\r\n\r\n    return true;\r\n}","startLine":6,"endLine":55,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\list.js","messages":[{"functionBody":"function skipBulletListMarker(state, startLine) {\r\n    var marker, pos, max;\r\n    pos = state.bMarks[startLine] + state.tShift[startLine];\r\n    max = state.eMarks[startLine];\r\n\r\n    if (pos >= max) {\r\n        return -1;\r\n    }\r\n\r\n    marker = state.src.charCodeAt(pos++);\r\n\r\n    if (marker !== 0x2A && marker !== 0x2D && marker !== 0x2B) {\r\n        return -1;\r\n    }\r\n\r\n    if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\r\n        return -1;\r\n    }\r\n\r\n    return pos;\r\n}","startLine":8,"endLine":30,"nodeType":"FunctionDeclaration"},{"functionBody":"function skipOrderedListMarker(state, startLine) {\r\n    var ch, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\r\n\r\n    if (pos + 1 >= max) {\r\n        return -1;\r\n    }\r\n\r\n    ch = state.src.charCodeAt(pos++);\r\n\r\n    if (ch < 0x30 || ch > 0x39) {\r\n        return -1;\r\n    }\r\n\r\n    for (; ; ) {\r\n        if (pos >= max) {\r\n            return -1;\r\n        }\r\n\r\n        ch = state.src.charCodeAt(pos++);\r\n\r\n        if (ch >= 0x30 && ch <= 0x39) {\r\n            continue;\r\n        }\r\n\r\n        if (ch === 0x29 || ch === 0x2e) {\r\n            break;\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\r\n        return -1;\r\n    }\r\n\r\n    return pos;\r\n}","startLine":34,"endLine":69,"nodeType":"FunctionDeclaration"},{"functionBody":"function markTightParagraphs(state, idx) {\r\n    var i, l, level = state.level + 2;\r\n\r\n    for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\r\n        if (state.tokens[i].level === level && state.tokens[i].type === \"paragraph_open\") {\r\n            state.tokens[i + 2].tight = true;\r\n            state.tokens[i].tight = true;\r\n            i += 2;\r\n        }\r\n    }\r\n}","startLine":71,"endLine":82,"nodeType":"FunctionDeclaration"},{"functionBody":"function list(state, startLine, endLine, silent) {\r\n    var nextLine, indent, oldTShift, oldIndent, oldTight, oldParentType, start, posAfterMarker, max, indentAfterMarker, markerValue, markerCharCode, isOrdered, contentStart, listTokIdx, prevEmptyEnd, listLines, itemLines, tight = true, terminatorRules, i, l, terminate;\r\n\r\n    if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\r\n        isOrdered = true;\r\n    } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\r\n        isOrdered = false;\r\n    } else {\r\n        return false;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\r\n\r\n    if (silent) {\r\n        return true;\r\n    }\r\n\r\n    listTokIdx = state.tokens.length;\r\n\r\n    if (isOrdered) {\r\n        start = state.bMarks[startLine] + state.tShift[startLine];\r\n        markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\r\n\r\n        state.tokens.push({\r\n            type: \"ordered_list_open\",\r\n            order: markerValue,\r\n            lines: listLines = [startLine, 0],\r\n            level: state.level++\r\n        });\r\n    } else {\r\n        state.tokens.push({\r\n            type: \"bullet_list_open\",\r\n            lines: listLines = [startLine, 0],\r\n            level: state.level++\r\n        });\r\n    }\r\n\r\n    nextLine = startLine;\r\n    prevEmptyEnd = false;\r\n    terminatorRules = state.parser.ruler.getRules(\"list\");\r\n\r\n    while (nextLine < endLine) {\r\n        contentStart = state.skipSpaces(posAfterMarker);\r\n        max = state.eMarks[nextLine];\r\n\r\n        if (contentStart >= max) {\r\n            indentAfterMarker = 1;\r\n        } else {\r\n            indentAfterMarker = contentStart - posAfterMarker;\r\n        }\r\n\r\n        if (indentAfterMarker > 4) {\r\n            indentAfterMarker = 1;\r\n        }\r\n\r\n        if (indentAfterMarker < 1) {\r\n            indentAfterMarker = 1;\r\n        }\r\n\r\n        indent = posAfterMarker - state.bMarks[nextLine] + indentAfterMarker;\r\n\r\n        state.tokens.push({\r\n            type: \"list_item_open\",\r\n            lines: itemLines = [startLine, 0],\r\n            level: state.level++\r\n        });\r\n\r\n        oldIndent = state.blkIndent;\r\n        oldTight = state.tight;\r\n        oldTShift = state.tShift[startLine];\r\n        oldParentType = state.parentType;\r\n        state.tShift[startLine] = contentStart - state.bMarks[startLine];\r\n        state.blkIndent = indent;\r\n        state.tight = true;\r\n        state.parentType = \"list\";\r\n        state.parser.tokenize(state, startLine, endLine, true);\r\n\r\n        if (!state.tight || prevEmptyEnd) {\r\n            tight = false;\r\n        }\r\n\r\n        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\r\n        state.blkIndent = oldIndent;\r\n        state.tShift[startLine] = oldTShift;\r\n        state.tight = oldTight;\r\n        state.parentType = oldParentType;\r\n\r\n        state.tokens.push({\r\n            type: \"list_item_close\",\r\n            level: --state.level\r\n        });\r\n\r\n        nextLine = startLine = state.line;\r\n        itemLines[1] = nextLine;\r\n        contentStart = state.bMarks[startLine];\r\n\r\n        if (nextLine >= endLine) {\r\n            break;\r\n        }\r\n\r\n        if (state.isEmpty(nextLine)) {\r\n            break;\r\n        }\r\n\r\n        if (state.tShift[nextLine] < state.blkIndent) {\r\n            break;\r\n        }\r\n\r\n        terminate = false;\r\n\r\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\r\n            if (terminatorRules[i](state, nextLine, endLine, true)) {\r\n                terminate = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (terminate) {\r\n            break;\r\n        }\r\n\r\n        if (isOrdered) {\r\n            posAfterMarker = skipOrderedListMarker(state, nextLine);\r\n\r\n            if (posAfterMarker < 0) {\r\n                break;\r\n            }\r\n        } else {\r\n            posAfterMarker = skipBulletListMarker(state, nextLine);\r\n\r\n            if (posAfterMarker < 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    state.tokens.push({\r\n        type: isOrdered ? \"ordered_list_close\" : \"bullet_list_close\",\r\n        level: --state.level\r\n    });\r\n\r\n    listLines[1] = nextLine;\r\n    state.line = nextLine;\r\n\r\n    if (tight) {\r\n        markTightParagraphs(state, listTokIdx);\r\n    }\r\n\r\n    return true;\r\n}","startLine":85,"endLine":266,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\paragraph.js","messages":[{"functionBody":"function paragraph(state, startLine) {\r\n    var endLine, content, terminate, i, l, nextLine = startLine + 1, terminatorRules;\r\n    endLine = state.lineMax;\r\n\r\n    if (nextLine < endLine && !state.isEmpty(nextLine)) {\r\n        terminatorRules = state.parser.ruler.getRules(\"paragraph\");\r\n\r\n        for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\r\n            if (state.tShift[nextLine] - state.blkIndent > 3) {\r\n                continue;\r\n            }\r\n\r\n            terminate = false;\r\n\r\n            for (i = 0, l = terminatorRules.length; i < l; i++) {\r\n                if (terminatorRules[i](state, nextLine, endLine, true)) {\r\n                    terminate = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (terminate) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\r\n    state.line = nextLine;\r\n\r\n    if (content.length) {\r\n        state.tokens.push({\r\n            type: \"paragraph_open\",\r\n            tight: false,\r\n            lines: [startLine, state.line],\r\n            level: state.level\r\n        });\r\n\r\n        state.tokens.push({\r\n            type: \"inline\",\r\n            content: content,\r\n            level: state.level + 1,\r\n            lines: [startLine, state.line],\r\n            children: []\r\n        });\r\n\r\n        state.tokens.push({\r\n            type: \"paragraph_close\",\r\n            tight: false,\r\n            level: state.level\r\n        });\r\n    }\r\n\r\n    return true;\r\n}","startLine":6,"endLine":59,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\state_block.js","messages":[{"functionBody":"function StateBlock(src, parser, options, env, tokens) {\r\n    var ch, s, start, pos, len, indent, indent_found;\r\n    this.src = src;\r\n    this.parser = parser;\r\n    this.options = options;\r\n    this.env = env;\r\n    this.tokens = tokens;\r\n    this.bMarks = [];\r\n    this.eMarks = [];\r\n    this.tShift = [];\r\n    this.blkIndent = 0;\r\n    this.line = 0;\r\n    this.lineMax = 0;\r\n    this.tight = false;\r\n    this.parentType = \"root\";\r\n    this.ddIndent = -1;\r\n    this.level = 0;\r\n    this.result = \"\";\r\n    s = this.src;\r\n    indent = 0;\r\n    indent_found = false;\r\n\r\n    for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\r\n        ch = s.charCodeAt(pos);\r\n\r\n        if (!indent_found) {\r\n            if (ch === 0x20) {\r\n                indent++;\r\n                continue;\r\n            } else {\r\n                indent_found = true;\r\n            }\r\n        }\r\n\r\n        if (ch === 0x0A || pos === len - 1) {\r\n            if (ch !== 0x0A) {\r\n                pos++;\r\n            }\r\n\r\n            this.bMarks.push(start);\r\n            this.eMarks.push(pos);\r\n            this.tShift.push(indent);\r\n            indent_found = false;\r\n            indent = 0;\r\n            start = pos + 1;\r\n        }\r\n    }\r\n\r\n    this.bMarks.push(s.length);\r\n    this.eMarks.push(s.length);\r\n    this.tShift.push(0);\r\n    this.lineMax = this.bMarks.length - 1;\r\n}","startLine":6,"endLine":78,"nodeType":"FunctionDeclaration"},{"functionBody":"function isEmpty(line) {\r\n    return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\r\n}","startLine":80,"endLine":82,"nodeType":"FunctionExpression"},{"functionBody":"function skipEmptyLines(from) {\r\n    for (var max = this.lineMax; from < max; from++) {\r\n        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return from;\r\n}","startLine":84,"endLine":91,"nodeType":"FunctionExpression"},{"functionBody":"function skipSpaces(pos) {\r\n    for (var max = this.src.length; pos < max; pos++) {\r\n        if (this.src.charCodeAt(pos) !== 0x20) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return pos;\r\n}","startLine":94,"endLine":99,"nodeType":"FunctionExpression"},{"functionBody":"function skipChars(pos, code) {\r\n    for (var max = this.src.length; pos < max; pos++) {\r\n        if (this.src.charCodeAt(pos) !== code) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return pos;\r\n}","startLine":102,"endLine":107,"nodeType":"FunctionExpression"},{"functionBody":"function skipCharsBack(pos, code, min) {\r\n    if (pos <= min) {\r\n        return pos;\r\n    }\r\n\r\n    while (pos > min) {\r\n        if (code !== this.src.charCodeAt(--pos)) {\r\n            return pos + 1;\r\n        }\r\n    }\r\n\r\n    return pos;\r\n}","startLine":110,"endLine":117,"nodeType":"FunctionExpression"},{"functionBody":"function getLines(begin, end, indent, keepLastLF) {\r\n    var i, first, last, queue, shift, line = begin;\r\n\r\n    if (begin >= end) {\r\n        return \"\";\r\n    }\r\n\r\n    if (line + 1 === end) {\r\n        first = this.bMarks[line] + Math.min(this.tShift[line], indent);\r\n        last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];\r\n        return this.src.slice(first, last);\r\n    }\r\n\r\n    queue = new Array(end - begin);\r\n\r\n    for (i = 0; line < end; line++, i++) {\r\n        shift = this.tShift[line];\r\n\r\n        if (shift > indent) {\r\n            shift = indent;\r\n        }\r\n\r\n        if (shift < 0) {\r\n            shift = 0;\r\n        }\r\n\r\n        first = this.bMarks[line] + shift;\r\n\r\n        if (line + 1 < end || keepLastLF) {\r\n            last = this.eMarks[line] + 1;\r\n        } else {\r\n            last = this.eMarks[line];\r\n        }\r\n\r\n        queue[i] = this.src.slice(first, last);\r\n    }\r\n\r\n    return queue.join(\"\");\r\n}","startLine":120,"endLine":155,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_block\\table.js","messages":[{"functionBody":"function getLine(state, line) {\r\n    var pos = state.bMarks[line] + state.blkIndent, max = state.eMarks[line];\r\n    return state.src.substr(pos, max - pos);\r\n}","startLine":6,"endLine":11,"nodeType":"FunctionDeclaration"},{"functionBody":"function table(state, startLine, endLine, silent) {\r\n    var ch, lineText, pos, i, nextLine, rows, cell, aligns, t, tableLines, tbodyLines;\r\n\r\n    if (startLine + 2 > endLine) {\r\n        return false;\r\n    }\r\n\r\n    nextLine = startLine + 1;\r\n\r\n    if (state.tShift[nextLine] < state.blkIndent) {\r\n        return false;\r\n    }\r\n\r\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\r\n\r\n    if (pos >= state.eMarks[nextLine]) {\r\n        return false;\r\n    }\r\n\r\n    ch = state.src.charCodeAt(pos);\r\n\r\n    if (ch !== 0x7C && ch !== 0x2D && ch !== 0x3A) {\r\n        return false;\r\n    }\r\n\r\n    lineText = getLine(state, startLine + 1);\r\n\r\n    if (!/^[-:| ]+$/.test(lineText)) {\r\n        return false;\r\n    }\r\n\r\n    rows = lineText.split(\"|\");\r\n\r\n    if (rows <= 2) {\r\n        return false;\r\n    }\r\n\r\n    aligns = [];\r\n\r\n    for (i = 0; i < rows.length; i++) {\r\n        t = rows[i].trim();\r\n\r\n        if (!t) {\r\n            if (i === 0 || i === rows.length - 1) {\r\n                continue;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (!/^:?-+:?$/.test(t)) {\r\n            return false;\r\n        }\r\n\r\n        if (t.charCodeAt(t.length - 1) === 0x3A) {\r\n            aligns.push(t.charCodeAt(0) === 0x3A ? \"center\" : \"right\");\r\n        } else if (t.charCodeAt(0) === 0x3A) {\r\n            aligns.push(\"left\");\r\n        } else {\r\n            aligns.push(\"\");\r\n        }\r\n    }\r\n\r\n    lineText = getLine(state, startLine).trim();\r\n\r\n    if (lineText.indexOf(\"|\") === -1) {\r\n        return false;\r\n    }\r\n\r\n    rows = lineText.replace(/^\\||\\|$/g, \"\").split(\"|\");\r\n\r\n    if (aligns.length !== rows.length) {\r\n        return false;\r\n    }\r\n\r\n    if (silent) {\r\n        return true;\r\n    }\r\n\r\n    state.tokens.push({\r\n        type: \"table_open\",\r\n        lines: tableLines = [startLine, 0],\r\n        level: state.level++\r\n    });\r\n\r\n    state.tokens.push({\r\n        type: \"thead_open\",\r\n        lines: [startLine, startLine + 1],\r\n        level: state.level++\r\n    });\r\n\r\n    state.tokens.push({\r\n        type: \"tr_open\",\r\n        lines: [startLine, startLine + 1],\r\n        level: state.level++\r\n    });\r\n\r\n    for (i = 0; i < rows.length; i++) {\r\n        state.tokens.push({\r\n            type: \"th_open\",\r\n            align: aligns[i],\r\n            lines: [startLine, startLine + 1],\r\n            level: state.level++\r\n        });\r\n\r\n        state.tokens.push({\r\n            type: \"inline\",\r\n            content: rows[i].trim(),\r\n            lines: [startLine, startLine + 1],\r\n            level: state.level,\r\n            children: []\r\n        });\r\n\r\n        state.tokens.push({\r\n            type: \"th_close\",\r\n            level: --state.level\r\n        });\r\n    }\r\n\r\n    state.tokens.push({\r\n        type: \"tr_close\",\r\n        level: --state.level\r\n    });\r\n\r\n    state.tokens.push({\r\n        type: \"thead_close\",\r\n        level: --state.level\r\n    });\r\n\r\n    state.tokens.push({\r\n        type: \"tbody_open\",\r\n        lines: tbodyLines = [startLine + 2, 0],\r\n        level: state.level++\r\n    });\r\n\r\n    for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\r\n        if (state.tShift[nextLine] < state.blkIndent) {\r\n            break;\r\n        }\r\n\r\n        lineText = getLine(state, nextLine).trim();\r\n\r\n        if (lineText.indexOf(\"|\") === -1) {\r\n            break;\r\n        }\r\n\r\n        rows = lineText.replace(/^\\||\\|$/g, \"\").split(\"|\");\r\n\r\n        state.tokens.push({\r\n            type: \"tr_open\",\r\n            level: state.level++\r\n        });\r\n\r\n        for (i = 0; i < rows.length; i++) {\r\n            state.tokens.push({\r\n                type: \"td_open\",\r\n                align: aligns[i],\r\n                level: state.level++\r\n            });\r\n\r\n            cell = rows[i].substring(\r\n                rows[i].charCodeAt(0) === 0x7c ? 1 : 0,\r\n                rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length\r\n            ).trim();\r\n\r\n            state.tokens.push({\r\n                type: \"inline\",\r\n                content: cell,\r\n                level: state.level,\r\n                children: []\r\n            });\r\n\r\n            state.tokens.push({\r\n                type: \"td_close\",\r\n                level: --state.level\r\n            });\r\n        }\r\n\r\n        state.tokens.push({\r\n            type: \"tr_close\",\r\n            level: --state.level\r\n        });\r\n    }\r\n\r\n    state.tokens.push({\r\n        type: \"tbody_close\",\r\n        level: --state.level\r\n    });\r\n\r\n    state.tokens.push({\r\n        type: \"table_close\",\r\n        level: --state.level\r\n    });\r\n\r\n    tableLines[1] = tbodyLines[1] = nextLine;\r\n    state.line = nextLine;\r\n    return true;\r\n}","startLine":13,"endLine":138,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_core\\abbr.js","messages":[{"functionBody":"function parseAbbr(str, parserInline, options, env) {\r\n    var state, labelEnd, pos, max, label, title;\r\n\r\n    if (str.charCodeAt(0) !== 0x2A) {\r\n        return -1;\r\n    }\r\n\r\n    if (str.charCodeAt(1) !== 0x5B) {\r\n        return -1;\r\n    }\r\n\r\n    if (str.indexOf(\"]:\") === -1) {\r\n        return -1;\r\n    }\r\n\r\n    state = new StateInline(str, parserInline, options, env, []);\r\n    labelEnd = parseLinkLabel(state, 1);\r\n\r\n    if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A) {\r\n        return -1;\r\n    }\r\n\r\n    max = state.posMax;\r\n\r\n    for (pos = labelEnd + 2; pos < max; pos++) {\r\n        if (state.src.charCodeAt(pos) === 0x0A) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    label = str.slice(2, labelEnd);\r\n    title = str.slice(labelEnd + 2, pos).trim();\r\n\r\n    if (title.length === 0) {\r\n        return -1;\r\n    }\r\n\r\n    if (!env.abbreviations) {\r\n        env.abbreviations = {};\r\n    }\r\n\r\n    if (typeof env.abbreviations[\":\" + label] === \"undefined\") {\r\n        env.abbreviations[\":\" + label] = title;\r\n    }\r\n\r\n    return pos;\r\n}","startLine":11,"endLine":41,"nodeType":"FunctionDeclaration"},{"functionBody":"function abbr(state) {\r\n    var tokens = state.tokens, i, l, content, pos;\r\n\r\n    if (state.inlineMode) {\r\n        return;\r\n    }\r\n\r\n    for (i = 1, l = tokens.length - 1; i < l; i++) {\r\n        if (tokens[i - 1].type === \"paragraph_open\" && tokens[i].type === \"inline\" && tokens[i + 1].type === \"paragraph_close\") {\r\n            content = tokens[i].content;\r\n\r\n            while (content.length) {\r\n                pos = parseAbbr(content, state.inline, state.options, state.env);\r\n\r\n                if (pos < 0) {\r\n                    break;\r\n                }\r\n\r\n                content = content.slice(pos).trim();\r\n            }\r\n\r\n            tokens[i].content = content;\r\n\r\n            if (!content.length) {\r\n                tokens[i - 1].tight = true;\r\n                tokens[i + 1].tight = true;\r\n            }\r\n        }\r\n    }\r\n}","startLine":43,"endLine":70,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_core\\abbr2.js","messages":[{"functionBody":"function regEscape(s) {\r\n    return s.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, \"\\\\$1\");\r\n}","startLine":11,"endLine":13,"nodeType":"FunctionDeclaration"},{"functionBody":"function abbr2(state) {\r\n    var i, j, l, tokens, token, text, nodes, pos, level, reg, m, regText, blockTokens = state.tokens;\r\n\r\n    if (!state.env.abbreviations) {\r\n        return;\r\n    }\r\n\r\n    if (!state.env.abbrRegExp) {\r\n        regText = \"(^|[\" + PUNCT_CHARS.split(\"\").map(regEscape).join(\"\") + \"])\" + \"(\" + Object.keys(state.env.abbreviations).map(function(x) {\r\n            return x.substr(1);\r\n        }).sort(function(a, b) {\r\n            return b.length - a.length;\r\n        }).map(regEscape).join(\"|\") + \")\" + \"($|[\" + PUNCT_CHARS.split(\"\").map(regEscape).join(\"\") + \"])\";\r\n\r\n        state.env.abbrRegExp = new RegExp(regText, \"g\");\r\n    }\r\n\r\n    reg = state.env.abbrRegExp;\r\n\r\n    for (j = 0, l = blockTokens.length; j < l; j++) {\r\n        if (blockTokens[j].type !== \"inline\") {\r\n            continue;\r\n        }\r\n\r\n        tokens = blockTokens[j].children;\r\n\r\n        for (i = tokens.length - 1; i >= 0; i--) {\r\n            token = tokens[i];\r\n\r\n            if (token.type !== \"text\") {\r\n                continue;\r\n            }\r\n\r\n            pos = 0;\r\n            text = token.content;\r\n            reg.lastIndex = 0;\r\n            level = token.level;\r\n            nodes = [];\r\n\r\n            while (m = reg.exec(text)) {\r\n                if (reg.lastIndex > pos) {\r\n                    nodes.push({\r\n                        type: \"text\",\r\n                        content: text.slice(pos, m.index + m[1].length),\r\n                        level: level\r\n                    });\r\n                }\r\n\r\n                nodes.push({\r\n                    type: \"abbr_open\",\r\n                    title: state.env.abbreviations[\":\" + m[2]],\r\n                    level: level++\r\n                });\r\n\r\n                nodes.push({\r\n                    type: \"text\",\r\n                    content: m[2],\r\n                    level: level\r\n                });\r\n\r\n                nodes.push({\r\n                    type: \"abbr_close\",\r\n                    level: --level\r\n                });\r\n\r\n                pos = reg.lastIndex - m[3].length;\r\n            }\r\n\r\n            if (!nodes.length) {\r\n                continue;\r\n            }\r\n\r\n            if (pos < text.length) {\r\n                nodes.push({\r\n                    type: \"text\",\r\n                    content: text.slice(pos),\r\n                    level: level\r\n                });\r\n            }\r\n\r\n            blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\r\n        }\r\n    }\r\n}","startLine":16,"endLine":88,"nodeType":"FunctionExpression"},{"functionBody":"function(x) {\r\n    return x.substr(1);\r\n}","startLine":23,"endLine":25,"nodeType":"FunctionExpression"},{"functionBody":"function(a, b) {\r\n    return b.length - a.length;\r\n}","startLine":25,"endLine":27,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_core\\block.js","messages":[{"functionBody":"function block(state) {\r\n    if (state.inlineMode) {\r\n        state.tokens.push({\r\n            type: \"inline\",\r\n            content: state.src.replace(/\\n/g, \" \").trim(),\r\n            level: 0,\r\n            lines: [0, 1],\r\n            children: []\r\n        });\r\n    } else {\r\n        state.block.parse(state.src, state.options, state.env, state.tokens);\r\n    }\r\n}","startLine":3,"endLine":17,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_core\\footnote_tail.js","messages":[{"functionBody":"function footnote_block(state) {\r\n    var i, l, j, t, lastParagraph, list, tokens, current, currentLabel, level = 0, insideRef = false, refTokens = {};\r\n\r\n    if (!state.env.footnotes) {\r\n        return;\r\n    }\r\n\r\n    state.tokens = state.tokens.filter(function(tok) {\r\n        if (tok.type === \"footnote_reference_open\") {\r\n            insideRef = true;\r\n            current = [];\r\n            currentLabel = tok.label;\r\n            return false;\r\n        }\r\n\r\n        if (tok.type === \"footnote_reference_close\") {\r\n            insideRef = false;\r\n            refTokens[\":\" + currentLabel] = current;\r\n            return false;\r\n        }\r\n\r\n        if (insideRef) {\r\n            current.push(tok);\r\n        }\r\n\r\n        return !insideRef;\r\n    });\r\n\r\n    if (!state.env.footnotes.list) {\r\n        return;\r\n    }\r\n\r\n    list = state.env.footnotes.list;\r\n\r\n    state.tokens.push({\r\n        type: \"footnote_block_open\",\r\n        level: level++\r\n    });\r\n\r\n    for (i = 0, l = list.length; i < l; i++) {\r\n        state.tokens.push({\r\n            type: \"footnote_open\",\r\n            id: i,\r\n            level: level++\r\n        });\r\n\r\n        if (list[i].tokens) {\r\n            tokens = [];\r\n\r\n            tokens.push({\r\n                type: \"paragraph_open\",\r\n                tight: false,\r\n                level: level++\r\n            });\r\n\r\n            tokens.push({\r\n                type: \"inline\",\r\n                content: \"\",\r\n                level: level,\r\n                children: list[i].tokens\r\n            });\r\n\r\n            tokens.push({\r\n                type: \"paragraph_close\",\r\n                tight: false,\r\n                level: --level\r\n            });\r\n        } else if (list[i].label) {\r\n            tokens = refTokens[\":\" + list[i].label];\r\n        }\r\n\r\n        state.tokens = state.tokens.concat(tokens);\r\n\r\n        if (state.tokens[state.tokens.length - 1].type === \"paragraph_close\") {\r\n            lastParagraph = state.tokens.pop();\r\n        } else {\r\n            lastParagraph = null;\r\n        }\r\n\r\n        t = list[i].count > 0 ? list[i].count : 1;\r\n\r\n        for (j = 0; j < t; j++) {\r\n            state.tokens.push({\r\n                type: \"footnote_anchor\",\r\n                id: i,\r\n                subId: j,\r\n                level: level\r\n            });\r\n        }\r\n\r\n        if (lastParagraph) {\r\n            state.tokens.push(lastParagraph);\r\n        }\r\n\r\n        state.tokens.push({\r\n            type: \"footnote_close\",\r\n            level: --level\r\n        });\r\n    }\r\n\r\n    state.tokens.push({\r\n        type: \"footnote_block_close\",\r\n        level: --level\r\n    });\r\n}","startLine":4,"endLine":95,"nodeType":"FunctionExpression"},{"functionBody":"function(tok) {\r\n    if (tok.type === \"footnote_reference_open\") {\r\n        insideRef = true;\r\n        current = [];\r\n        currentLabel = tok.label;\r\n        return false;\r\n    }\r\n\r\n    if (tok.type === \"footnote_reference_close\") {\r\n        insideRef = false;\r\n        refTokens[\":\" + currentLabel] = current;\r\n        return false;\r\n    }\r\n\r\n    if (insideRef) {\r\n        current.push(tok);\r\n    }\r\n\r\n    return !insideRef;\r\n}","startLine":12,"endLine":27,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_core\\inline.js","messages":[{"functionBody":"function inline(state) {\r\n    var tokens = state.tokens, tok, i, l;\r\n\r\n    for (i = 0, l = tokens.length; i < l; i++) {\r\n        tok = tokens[i];\r\n\r\n        if (tok.type === \"inline\") {\r\n            state.inline.parse(tok.content, state.options, state.env, tok.children);\r\n        }\r\n    }\r\n}","startLine":3,"endLine":13,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_core\\linkify.js","messages":[{"functionBody":"function isLinkOpen(str) {\r\n    return /^<a[>\\s]/i.test(str);\r\n}","startLine":14,"endLine":16,"nodeType":"FunctionDeclaration"},{"functionBody":"function isLinkClose(str) {\r\n    return /^<\\/a\\s*>/i.test(str);\r\n}","startLine":17,"endLine":19,"nodeType":"FunctionDeclaration"},{"functionBody":"function createLinkifier() {\r\n    var links = [];\r\n\r\n    var autolinker = new Autolinker({\r\n        stripPrefix: false,\r\n        url: true,\r\n        email: true,\r\n        twitter: false,\r\n\r\n        replaceFn: function(linker, match) {\r\n            switch (match.getType()) {\r\n            case \"url\":\r\n                links.push({\r\n                    text: match.matchedText,\r\n                    url: match.getUrl()\r\n                });\r\n\r\n                break;\r\n            case \"email\":\r\n                links.push({\r\n                    text: match.matchedText,\r\n                    url: \"mailto:\" + match.getEmail().replace(/^mailto:/i, \"\")\r\n                });\r\n\r\n                break;\r\n            }\r\n\r\n            return false;\r\n        }\r\n    });\r\n\r\n    return {\r\n        links: links,\r\n        autolinker: autolinker\r\n    };\r\n}","startLine":24,"endLine":57,"nodeType":"FunctionDeclaration"},{"functionBody":"function(linker, match) {\r\n    switch (match.getType()) {\r\n    case \"url\":\r\n        links.push({\r\n            text: match.matchedText,\r\n            url: match.getUrl()\r\n        });\r\n\r\n        break;\r\n    case \"email\":\r\n        links.push({\r\n            text: match.matchedText,\r\n            url: \"mailto:\" + match.getEmail().replace(/^mailto:/i, \"\")\r\n        });\r\n\r\n        break;\r\n    }\r\n\r\n    return false;\r\n}","startLine":31,"endLine":50,"nodeType":"FunctionExpression"},{"functionBody":"function linkify(state) {\r\n    var i, j, l, tokens, token, text, nodes, ln, pos, level, htmlLinkLevel, blockTokens = state.tokens, linkifier = null, links, autolinker;\r\n\r\n    if (!state.options.linkify) {\r\n        return;\r\n    }\r\n\r\n    for (j = 0, l = blockTokens.length; j < l; j++) {\r\n        if (blockTokens[j].type !== \"inline\") {\r\n            continue;\r\n        }\r\n\r\n        tokens = blockTokens[j].children;\r\n        htmlLinkLevel = 0;\r\n\r\n        for (i = tokens.length - 1; i >= 0; i--) {\r\n            token = tokens[i];\r\n\r\n            if (token.type === \"link_close\") {\r\n                i--;\r\n\r\n                while (tokens[i].level !== token.level && tokens[i].type !== \"link_open\") {\r\n                    i--;\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            if (token.type === \"htmltag\") {\r\n                if (isLinkOpen(token.content) && htmlLinkLevel > 0) {\r\n                    htmlLinkLevel--;\r\n                }\r\n\r\n                if (isLinkClose(token.content)) {\r\n                    htmlLinkLevel++;\r\n                }\r\n            }\r\n\r\n            if (htmlLinkLevel > 0) {\r\n                continue;\r\n            }\r\n\r\n            if (token.type === \"text\" && LINK_SCAN_RE.test(token.content)) {\r\n                if (!linkifier) {\r\n                    linkifier = createLinkifier();\r\n                    links = linkifier.links;\r\n                    autolinker = linkifier.autolinker;\r\n                }\r\n\r\n                text = token.content;\r\n                links.length = 0;\r\n                autolinker.link(text);\r\n\r\n                if (!links.length) {\r\n                    continue;\r\n                }\r\n\r\n                nodes = [];\r\n                level = token.level;\r\n\r\n                for (ln = 0; ln < links.length; ln++) {\r\n                    if (!state.inline.validateLink(links[ln].url)) {\r\n                        continue;\r\n                    }\r\n\r\n                    pos = text.indexOf(links[ln].text);\r\n\r\n                    if (pos) {\r\n                        level = level;\r\n\r\n                        nodes.push({\r\n                            type: \"text\",\r\n                            content: text.slice(0, pos),\r\n                            level: level\r\n                        });\r\n                    }\r\n\r\n                    nodes.push({\r\n                        type: \"link_open\",\r\n                        href: links[ln].url,\r\n                        title: \"\",\r\n                        level: level++\r\n                    });\r\n\r\n                    nodes.push({\r\n                        type: \"text\",\r\n                        content: links[ln].text,\r\n                        level: level\r\n                    });\r\n\r\n                    nodes.push({\r\n                        type: \"link_close\",\r\n                        level: --level\r\n                    });\r\n\r\n                    text = text.slice(pos + links[ln].text.length);\r\n                }\r\n\r\n                if (text.length) {\r\n                    nodes.push({\r\n                        type: \"text\",\r\n                        content: text,\r\n                        level: level\r\n                    });\r\n                }\r\n\r\n                blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\r\n            }\r\n        }\r\n    }\r\n}","startLine":60,"endLine":161,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_core\\references.js","messages":[{"functionBody":"function parseReference(str, parser, options, env) {\r\n    var state, labelEnd, pos, max, code, start, href, title, label;\r\n\r\n    if (str.charCodeAt(0) !== 0x5B) {\r\n        return -1;\r\n    }\r\n\r\n    if (str.indexOf(\"]:\") === -1) {\r\n        return -1;\r\n    }\r\n\r\n    state = new StateInline(str, parser, options, env, []);\r\n    labelEnd = parseLinkLabel(state, 0);\r\n\r\n    if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A) {\r\n        return -1;\r\n    }\r\n\r\n    max = state.posMax;\r\n\r\n    for (pos = labelEnd + 2; pos < max; pos++) {\r\n        code = state.src.charCodeAt(pos);\r\n\r\n        if (code !== 0x20 && code !== 0x0A) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!parseLinkDestination(state, pos)) {\r\n        return -1;\r\n    }\r\n\r\n    href = state.linkContent;\r\n    pos = state.pos;\r\n    start = pos;\r\n\r\n    for (pos = pos + 1; pos < max; pos++) {\r\n        code = state.src.charCodeAt(pos);\r\n\r\n        if (code !== 0x20 && code !== 0x0A) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\r\n        title = state.linkContent;\r\n        pos = state.pos;\r\n    } else {\r\n        title = \"\";\r\n        pos = start;\r\n    }\r\n\r\n    while (pos < max && state.src.charCodeAt(pos) === 0x20) {\r\n        pos++;\r\n    }\r\n\r\n    if (pos < max && state.src.charCodeAt(pos) !== 0x0A) {\r\n        return -1;\r\n    }\r\n\r\n    label = normalizeReference(str.slice(1, labelEnd));\r\n\r\n    if (typeof env.references[label] === \"undefined\") {\r\n        env.references[label] = {\r\n            title: title,\r\n            href: href\r\n        };\r\n    }\r\n\r\n    return pos;\r\n}","startLine":11,"endLine":66,"nodeType":"FunctionDeclaration"},{"functionBody":"function references(state) {\r\n    var tokens = state.tokens, i, l, content, pos;\r\n    state.env.references = state.env.references || {};\r\n\r\n    if (state.inlineMode) {\r\n        return;\r\n    }\r\n\r\n    for (i = 1, l = tokens.length - 1; i < l; i++) {\r\n        if (tokens[i].type === \"inline\" && tokens[i - 1].type === \"paragraph_open\" && tokens[i + 1].type === \"paragraph_close\") {\r\n            content = tokens[i].content;\r\n\r\n            while (content.length) {\r\n                pos = parseReference(content, state.inline, state.options, state.env);\r\n\r\n                if (pos < 0) {\r\n                    break;\r\n                }\r\n\r\n                content = content.slice(pos).trim();\r\n            }\r\n\r\n            tokens[i].content = content;\r\n\r\n            if (!content.length) {\r\n                tokens[i - 1].tight = true;\r\n                tokens[i + 1].tight = true;\r\n            }\r\n        }\r\n    }\r\n}","startLine":69,"endLine":98,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_core\\replacements.js","messages":[{"functionBody":"function replaceScopedAbbr(str) {\r\n    if (str.indexOf(\"(\") < 0) {\r\n        return str;\r\n    }\r\n\r\n    return str.replace(SCOPED_ABBR_RE, function(match, name) {\r\n        return SCOPED_ABBR[name.toLowerCase()];\r\n    });\r\n}","startLine":19,"endLine":25,"nodeType":"FunctionDeclaration"},{"functionBody":"function(match, name) {\r\n    return SCOPED_ABBR[name.toLowerCase()];\r\n}","startLine":22,"endLine":24,"nodeType":"FunctionExpression"},{"functionBody":"function replace(state) {\r\n    var i, token, text, inlineTokens, blkIdx;\r\n\r\n    if (!state.options.typographer) {\r\n        return;\r\n    }\r\n\r\n    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\r\n        if (state.tokens[blkIdx].type !== \"inline\") {\r\n            continue;\r\n        }\r\n\r\n        inlineTokens = state.tokens[blkIdx].children;\r\n\r\n        for (i = inlineTokens.length - 1; i >= 0; i--) {\r\n            token = inlineTokens[i];\r\n\r\n            if (token.type === \"text\") {\r\n                text = token.content;\r\n                text = replaceScopedAbbr(text);\r\n\r\n                if (RARE_RE.test(text)) {\r\n                    text = text.replace(/\\+-/g, \"Â±\").replace(/\\.{2,}/g, \"â€¦\").replace(/([?!])â€¦/g, \"$1..\").replace(/([?!]){4,}/g, \"$1$1$1\").replace(/,{2,}/g, \",\").replace(/(^|[^-])---([^-]|$)/gm, \"$1â€”$2\").replace(/(^|\\s)--(\\s|$)/gm, \"$1â€“$2\").replace(/(^|[^-\\s])--([^-\\s]|$)/gm, \"$1â€“$2\");\r\n                }\r\n\r\n                token.content = text;\r\n            }\r\n        }\r\n    }\r\n}","startLine":28,"endLine":64,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_core\\smartquotes.js","messages":[{"functionBody":"function isLetter(str, pos) {\r\n    if (pos < 0 || pos >= str.length) {\r\n        return false;\r\n    }\r\n\r\n    return !PUNCT_RE.test(str[pos]);\r\n}","startLine":13,"endLine":16,"nodeType":"FunctionDeclaration"},{"functionBody":"function replaceAt(str, index, ch) {\r\n    return str.substr(0, index) + ch + str.substr(index + 1);\r\n}","startLine":19,"endLine":21,"nodeType":"FunctionDeclaration"},{"functionBody":"function smartquotes(state) {\r\n    var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item, canOpen, canClose, j, isSingle, blkIdx, tokens, stack;\r\n\r\n    if (!state.options.typographer) {\r\n        return;\r\n    }\r\n\r\n    stack = [];\r\n\r\n    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\r\n        if (state.tokens[blkIdx].type !== \"inline\") {\r\n            continue;\r\n        }\r\n\r\n        tokens = state.tokens[blkIdx].children;\r\n        stack.length = 0;\r\n\r\n        for (i = 0; i < tokens.length; i++) {\r\n            token = tokens[i];\r\n\r\n            if (token.type !== \"text\" || QUOTE_TEST_RE.test(token.text)) {\r\n                continue;\r\n            }\r\n\r\n            thisLevel = tokens[i].level;\r\n\r\n            for (j = stack.length - 1; j >= 0; j--) {\r\n                if (stack[j].level <= thisLevel) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            stack.length = j + 1;\r\n            text = token.content;\r\n            pos = 0;\r\n            max = text.length;\r\n\r\n            OUTER:\r\n            while (pos < max) {\r\n                QUOTE_RE.lastIndex = pos;\r\n                t = QUOTE_RE.exec(text);\r\n\r\n                if (!t) {\r\n                    break;\r\n                }\r\n\r\n                lastSpace = !isLetter(text, t.index - 1);\r\n                pos = t.index + 1;\r\n                isSingle = t[0] === \"'\";\r\n                nextSpace = !isLetter(text, pos);\r\n\r\n                if (!nextSpace && !lastSpace) {\r\n                    if (isSingle) {\r\n                        token.content = replaceAt(token.content, t.index, APOSTROPHE);\r\n                    }\r\n\r\n                    continue;\r\n                }\r\n\r\n                canOpen = !nextSpace;\r\n                canClose = !lastSpace;\r\n\r\n                if (canClose) {\r\n                    for (j = stack.length - 1; j >= 0; j--) {\r\n                        item = stack[j];\r\n\r\n                        if (stack[j].level < thisLevel) {\r\n                            break;\r\n                        }\r\n\r\n                        if (item.single === isSingle && stack[j].level === thisLevel) {\r\n                            item = stack[j];\r\n\r\n                            if (isSingle) {\r\n                                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);\r\n                                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);\r\n                            } else {\r\n                                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);\r\n                                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);\r\n                            }\r\n\r\n                            stack.length = j;\r\n                            continue OUTER;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (canOpen) {\r\n                    stack.push({\r\n                        token: i,\r\n                        pos: t.index,\r\n                        single: isSingle,\r\n                        level: thisLevel\r\n                    });\r\n                } else if (canClose && isSingle) {\r\n                    token.content = replaceAt(token.content, t.index, APOSTROPHE);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","startLine":24,"endLine":113,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\autolink.js","messages":[{"functionBody":"function autolink(state, silent) {\r\n    var tail, linkMatch, emailMatch, url, fullUrl, pos = state.pos;\r\n\r\n    if (state.src.charCodeAt(pos) !== 0x3C) {\r\n        return false;\r\n    }\r\n\r\n    tail = state.src.slice(pos);\r\n\r\n    if (tail.indexOf(\">\") < 0) {\r\n        return false;\r\n    }\r\n\r\n    linkMatch = tail.match(AUTOLINK_RE);\r\n\r\n    if (linkMatch) {\r\n        if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) {\r\n            return false;\r\n        }\r\n\r\n        url = linkMatch[0].slice(1, -1);\r\n        fullUrl = normalizeLink(url);\r\n\r\n        if (!state.parser.validateLink(url)) {\r\n            return false;\r\n        }\r\n\r\n        if (!silent) {\r\n            state.push({\r\n                type: \"link_open\",\r\n                href: fullUrl,\r\n                level: state.level\r\n            });\r\n\r\n            state.push({\r\n                type: \"text\",\r\n                content: url,\r\n                level: state.level + 1\r\n            });\r\n\r\n            state.push({\r\n                type: \"link_close\",\r\n                level: state.level\r\n            });\r\n        }\r\n\r\n        state.pos += linkMatch[0].length;\r\n        return true;\r\n    }\r\n\r\n    emailMatch = tail.match(EMAIL_RE);\r\n\r\n    if (emailMatch) {\r\n        url = emailMatch[0].slice(1, -1);\r\n        fullUrl = normalizeLink(\"mailto:\" + url);\r\n\r\n        if (!state.parser.validateLink(fullUrl)) {\r\n            return false;\r\n        }\r\n\r\n        if (!silent) {\r\n            state.push({\r\n                type: \"link_open\",\r\n                href: fullUrl,\r\n                level: state.level\r\n            });\r\n\r\n            state.push({\r\n                type: \"text\",\r\n                content: url,\r\n                level: state.level + 1\r\n            });\r\n\r\n            state.push({\r\n                type: \"link_close\",\r\n                level: state.level\r\n            });\r\n        }\r\n\r\n        state.pos += emailMatch[0].length;\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}","startLine":14,"endLine":78,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\backticks.js","messages":[{"functionBody":"function backticks(state, silent) {\r\n    var start, max, marker, matchStart, matchEnd, pos = state.pos, ch = state.src.charCodeAt(pos);\r\n\r\n    if (ch !== 0x60) {\r\n        return false;\r\n    }\r\n\r\n    start = pos;\r\n    pos++;\r\n    max = state.posMax;\r\n\r\n    while (pos < max && state.src.charCodeAt(pos) === 0x60) {\r\n        pos++;\r\n    }\r\n\r\n    marker = state.src.slice(start, pos);\r\n    matchStart = matchEnd = pos;\r\n\r\n    while ((matchStart = state.src.indexOf(\"`\", matchEnd)) !== -1) {\r\n        matchEnd = matchStart + 1;\r\n\r\n        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60) {\r\n            matchEnd++;\r\n        }\r\n\r\n        if (matchEnd - matchStart === marker.length) {\r\n            if (!silent) {\r\n                state.push({\r\n                    type: \"code\",\r\n                    content: state.src.slice(pos, matchStart).replace(/[ \\n]+/g, \" \").trim(),\r\n                    block: false,\r\n                    level: state.level\r\n                });\r\n            }\r\n\r\n            state.pos = matchEnd;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    if (!silent) {\r\n        state.pending += marker;\r\n    }\r\n\r\n    state.pos += marker.length;\r\n    return true;\r\n}","startLine":5,"endLine":46,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\del.js","messages":[{"functionBody":"function del(state, silent) {\r\n    var found, pos, stack, max = state.posMax, start = state.pos, lastChar, nextChar;\r\n\r\n    if (state.src.charCodeAt(start) !== 0x7E) {\r\n        return false;\r\n    }\r\n\r\n    if (silent) {\r\n        return false;\r\n    }\r\n\r\n    if (start + 4 >= max) {\r\n        return false;\r\n    }\r\n\r\n    if (state.src.charCodeAt(start + 1) !== 0x7E) {\r\n        return false;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\r\n    nextChar = state.src.charCodeAt(start + 2);\r\n\r\n    if (lastChar === 0x7E) {\r\n        return false;\r\n    }\r\n\r\n    if (nextChar === 0x7E) {\r\n        return false;\r\n    }\r\n\r\n    if (nextChar === 0x20 || nextChar === 0x0A) {\r\n        return false;\r\n    }\r\n\r\n    pos = start + 2;\r\n\r\n    while (pos < max && state.src.charCodeAt(pos) === 0x7E) {\r\n        pos++;\r\n    }\r\n\r\n    if (pos > start + 3) {\r\n        state.pos += pos - start;\r\n\r\n        if (!silent) {\r\n            state.pending += state.src.slice(start, pos);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    state.pos = start + 2;\r\n    stack = 1;\r\n\r\n    while (state.pos + 1 < max) {\r\n        if (state.src.charCodeAt(state.pos) === 0x7E) {\r\n            if (state.src.charCodeAt(state.pos + 1) === 0x7E) {\r\n                lastChar = state.src.charCodeAt(state.pos - 1);\r\n                nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\r\n\r\n                if (nextChar !== 0x7E && lastChar !== 0x7E) {\r\n                    if (lastChar !== 0x20 && lastChar !== 0x0A) {\r\n                        stack--;\r\n                    } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\r\n                        stack++;\r\n                    }\r\n\r\n                    if (stack <= 0) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        state.parser.skipToken(state);\r\n    }\r\n\r\n    if (!found) {\r\n        state.pos = start;\r\n        return false;\r\n    }\r\n\r\n    state.posMax = state.pos;\r\n    state.pos = start + 2;\r\n\r\n    if (!silent) {\r\n        state.push({\r\n            type: \"del_open\",\r\n            level: state.level++\r\n        });\r\n\r\n        state.parser.tokenize(state);\r\n\r\n        state.push({\r\n            type: \"del_close\",\r\n            level: --state.level\r\n        });\r\n    }\r\n\r\n    state.pos = state.posMax + 2;\r\n    state.posMax = max;\r\n    return true;\r\n}","startLine":5,"endLine":84,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\emphasis.js","messages":[{"functionBody":"function isAlphaNum(code) {\r\n    return code >= 0x30 && code <= 0x39 || code >= 0x41 && code <= 0x5A || code >= 0x61 && code <= 0x7A;\r\n}","startLine":6,"endLine":10,"nodeType":"FunctionDeclaration"},{"functionBody":"function scanDelims(state, start) {\r\n    var pos = start, lastChar, nextChar, count, can_open = true, can_close = true, max = state.posMax, marker = state.src.charCodeAt(start);\r\n    lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\r\n\r\n    while (pos < max && state.src.charCodeAt(pos) === marker) {\r\n        pos++;\r\n    }\r\n\r\n    if (pos >= max) {\r\n        can_open = false;\r\n    }\r\n\r\n    count = pos - start;\r\n\r\n    if (count >= 4) {\r\n        can_open = can_close = false;\r\n    } else {\r\n        nextChar = pos < max ? state.src.charCodeAt(pos) : -1;\r\n\r\n        if (nextChar === 0x20 || nextChar === 0x0A) {\r\n            can_open = false;\r\n        }\r\n\r\n        if (lastChar === 0x20 || lastChar === 0x0A) {\r\n            can_close = false;\r\n        }\r\n\r\n        if (marker === 0x5F) {\r\n            if (isAlphaNum(lastChar)) {\r\n                can_open = false;\r\n            }\r\n\r\n            if (isAlphaNum(nextChar)) {\r\n                can_close = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        can_open: can_open,\r\n        can_close: can_close,\r\n        delims: count\r\n    };\r\n}","startLine":14,"endLine":49,"nodeType":"FunctionDeclaration"},{"functionBody":"function emphasis(state, silent) {\r\n    var startCount, count, found, oldCount, newCount, stack, res, max = state.posMax, start = state.pos, marker = state.src.charCodeAt(start);\r\n\r\n    if (marker !== 0x5F && marker !== 0x2A) {\r\n        return false;\r\n    }\r\n\r\n    if (silent) {\r\n        return false;\r\n    }\r\n\r\n    res = scanDelims(state, start);\r\n    startCount = res.delims;\r\n\r\n    if (!res.can_open) {\r\n        state.pos += startCount;\r\n\r\n        if (!silent) {\r\n            state.pending += state.src.slice(start, state.pos);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    state.pos = start + startCount;\r\n    stack = [startCount];\r\n\r\n    while (state.pos < max) {\r\n        if (state.src.charCodeAt(state.pos) === marker) {\r\n            res = scanDelims(state, state.pos);\r\n            count = res.delims;\r\n\r\n            if (res.can_close) {\r\n                oldCount = stack.pop();\r\n                newCount = count;\r\n\r\n                while (oldCount !== newCount) {\r\n                    if (newCount < oldCount) {\r\n                        stack.push(oldCount - newCount);\r\n                        break;\r\n                    }\r\n\r\n                    newCount -= oldCount;\r\n\r\n                    if (stack.length === 0) {\r\n                        break;\r\n                    }\r\n\r\n                    state.pos += oldCount;\r\n                    oldCount = stack.pop();\r\n                }\r\n\r\n                if (stack.length === 0) {\r\n                    startCount = oldCount;\r\n                    found = true;\r\n                    break;\r\n                }\r\n\r\n                state.pos += count;\r\n                continue;\r\n            }\r\n\r\n            if (res.can_open) {\r\n                stack.push(count);\r\n            }\r\n\r\n            state.pos += count;\r\n            continue;\r\n        }\r\n\r\n        state.parser.skipToken(state);\r\n    }\r\n\r\n    if (!found) {\r\n        state.pos = start;\r\n        return false;\r\n    }\r\n\r\n    state.posMax = state.pos;\r\n    state.pos = start + startCount;\r\n\r\n    if (!silent) {\r\n        if (startCount === 2 || startCount === 3) {\r\n            state.push({\r\n                type: \"strong_open\",\r\n                level: state.level++\r\n            });\r\n        }\r\n\r\n        if (startCount === 1 || startCount === 3) {\r\n            state.push({\r\n                type: \"em_open\",\r\n                level: state.level++\r\n            });\r\n        }\r\n\r\n        state.parser.tokenize(state);\r\n\r\n        if (startCount === 1 || startCount === 3) {\r\n            state.push({\r\n                type: \"em_close\",\r\n                level: --state.level\r\n            });\r\n        }\r\n\r\n        if (startCount === 2 || startCount === 3) {\r\n            state.push({\r\n                type: \"strong_close\",\r\n                level: --state.level\r\n            });\r\n        }\r\n    }\r\n\r\n    state.pos = state.posMax + startCount;\r\n    state.posMax = max;\r\n    return true;\r\n}","startLine":51,"endLine":149,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\entity.js","messages":[{"functionBody":"function entity(state, silent) {\r\n    var ch, code, match, pos = state.pos, max = state.posMax;\r\n\r\n    if (state.src.charCodeAt(pos) !== 0x26) {\r\n        return false;\r\n    }\r\n\r\n    if (pos + 1 < max) {\r\n        ch = state.src.charCodeAt(pos + 1);\r\n\r\n        if (ch === 0x23) {\r\n            match = state.src.slice(pos).match(DIGITAL_RE);\r\n\r\n            if (match) {\r\n                if (!silent) {\r\n                    code = match[1][0].toLowerCase() === \"x\" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\r\n                    state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\r\n                }\r\n\r\n                state.pos += match[0].length;\r\n                return true;\r\n            }\r\n        } else {\r\n            match = state.src.slice(pos).match(NAMED_RE);\r\n\r\n            if (match) {\r\n                if (has(entities, match[1])) {\r\n                    if (!silent) {\r\n                        state.pending += entities[match[1]];\r\n                    }\r\n\r\n                    state.pos += match[0].length;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!silent) {\r\n        state.pending += \"&\";\r\n    }\r\n\r\n    state.pos++;\r\n    return true;\r\n}","startLine":15,"endLine":48,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\escape.js","messages":[{"functionBody":"function(ch) {\r\n    ESCAPED[ch.charCodeAt(0)] = 1;\r\n}","startLine":10,"endLine":10,"nodeType":"FunctionExpression"},{"functionBody":"function escape(state, silent) {\r\n    var ch, pos = state.pos, max = state.posMax;\r\n\r\n    if (state.src.charCodeAt(pos) !== 0x5C) {\r\n        return false;\r\n    }\r\n\r\n    pos++;\r\n\r\n    if (pos < max) {\r\n        ch = state.src.charCodeAt(pos);\r\n\r\n        if (ch < 256 && ESCAPED[ch] !== 0) {\r\n            if (!silent) {\r\n                state.pending += state.src[pos];\r\n            }\r\n\r\n            state.pos += 2;\r\n            return true;\r\n        }\r\n\r\n        if (ch === 0x0A) {\r\n            if (!silent) {\r\n                state.push({\r\n                    type: \"hardbreak\",\r\n                    level: state.level\r\n                });\r\n            }\r\n\r\n            pos++;\r\n\r\n            while (pos < max && state.src.charCodeAt(pos) === 0x20) {\r\n                pos++;\r\n            }\r\n\r\n            state.pos = pos;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    if (!silent) {\r\n        state.pending += \"\\\\\";\r\n    }\r\n\r\n    state.pos++;\r\n    return true;\r\n}","startLine":13,"endLine":49,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\footnote_inline.js","messages":[{"functionBody":"function footnote_inline(state, silent) {\r\n    var labelStart, labelEnd, footnoteId, oldLength, max = state.posMax, start = state.pos;\r\n\r\n    if (start + 2 >= max) {\r\n        return false;\r\n    }\r\n\r\n    if (state.src.charCodeAt(start) !== 0x5E) {\r\n        return false;\r\n    }\r\n\r\n    if (state.src.charCodeAt(start + 1) !== 0x5B) {\r\n        return false;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    labelStart = start + 2;\r\n    labelEnd = parseLinkLabel(state, start + 1);\r\n\r\n    if (labelEnd < 0) {\r\n        return false;\r\n    }\r\n\r\n    if (!silent) {\r\n        if (!state.env.footnotes) {\r\n            state.env.footnotes = {};\r\n        }\r\n\r\n        if (!state.env.footnotes.list) {\r\n            state.env.footnotes.list = [];\r\n        }\r\n\r\n        footnoteId = state.env.footnotes.list.length;\r\n        state.pos = labelStart;\r\n        state.posMax = labelEnd;\r\n\r\n        state.push({\r\n            type: \"footnote_ref\",\r\n            id: footnoteId,\r\n            level: state.level\r\n        });\r\n\r\n        state.linkLevel++;\r\n        oldLength = state.tokens.length;\r\n        state.parser.tokenize(state);\r\n\r\n        state.env.footnotes.list[footnoteId] = {\r\n            tokens: state.tokens.splice(oldLength)\r\n        };\r\n\r\n        state.linkLevel--;\r\n    }\r\n\r\n    state.pos = labelEnd + 1;\r\n    state.posMax = max;\r\n    return true;\r\n}","startLine":8,"endLine":53,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\footnote_ref.js","messages":[{"functionBody":"function footnote_ref(state, silent) {\r\n    var label, pos, footnoteId, footnoteSubId, max = state.posMax, start = state.pos;\r\n\r\n    if (start + 3 > max) {\r\n        return false;\r\n    }\r\n\r\n    if (!state.env.footnotes || !state.env.footnotes.refs) {\r\n        return false;\r\n    }\r\n\r\n    if (state.src.charCodeAt(start) !== 0x5B) {\r\n        return false;\r\n    }\r\n\r\n    if (state.src.charCodeAt(start + 1) !== 0x5E) {\r\n        return false;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    for (pos = start + 2; pos < max; pos++) {\r\n        if (state.src.charCodeAt(pos) === 0x20) {\r\n            return false;\r\n        }\r\n\r\n        if (state.src.charCodeAt(pos) === 0x0A) {\r\n            return false;\r\n        }\r\n\r\n        if (state.src.charCodeAt(pos) === 0x5D) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (pos === start + 2) {\r\n        return false;\r\n    }\r\n\r\n    if (pos >= max) {\r\n        return false;\r\n    }\r\n\r\n    pos++;\r\n    label = state.src.slice(start + 2, pos - 1);\r\n\r\n    if (typeof state.env.footnotes.refs[\":\" + label] === \"undefined\") {\r\n        return false;\r\n    }\r\n\r\n    if (!silent) {\r\n        if (!state.env.footnotes.list) {\r\n            state.env.footnotes.list = [];\r\n        }\r\n\r\n        if (state.env.footnotes.refs[\":\" + label] < 0) {\r\n            footnoteId = state.env.footnotes.list.length;\r\n\r\n            state.env.footnotes.list[footnoteId] = {\r\n                label: label,\r\n                count: 0\r\n            };\r\n\r\n            state.env.footnotes.refs[\":\" + label] = footnoteId;\r\n        } else {\r\n            footnoteId = state.env.footnotes.refs[\":\" + label];\r\n        }\r\n\r\n        footnoteSubId = state.env.footnotes.list[footnoteId].count;\r\n        state.env.footnotes.list[footnoteId].count++;\r\n\r\n        state.push({\r\n            type: \"footnote_ref\",\r\n            id: footnoteId,\r\n            subId: footnoteSubId,\r\n            level: state.level\r\n        });\r\n    }\r\n\r\n    state.pos = pos;\r\n    state.posMax = max;\r\n    return true;\r\n}","startLine":6,"endLine":62,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\htmltag.js","messages":[{"functionBody":"function isLetter(ch) {\r\n    var lc = ch | 0x20;\r\n    return lc >= 0x61 && lc <= 0x7a;\r\n}","startLine":9,"endLine":13,"nodeType":"FunctionDeclaration"},{"functionBody":"function htmltag(state, silent) {\r\n    var ch, match, max, pos = state.pos;\r\n\r\n    if (!state.options.html) {\r\n        return false;\r\n    }\r\n\r\n    max = state.posMax;\r\n\r\n    if (state.src.charCodeAt(pos) !== 0x3C || pos + 2 >= max) {\r\n        return false;\r\n    }\r\n\r\n    ch = state.src.charCodeAt(pos + 1);\r\n\r\n    if (ch !== 0x21 && ch !== 0x3F && ch !== 0x2F && !isLetter(ch)) {\r\n        return false;\r\n    }\r\n\r\n    match = state.src.slice(pos).match(HTML_TAG_RE);\r\n\r\n    if (!match) {\r\n        return false;\r\n    }\r\n\r\n    if (!silent) {\r\n        state.push({\r\n            type: \"htmltag\",\r\n            content: state.src.slice(pos, pos + match[0].length),\r\n            level: state.level\r\n        });\r\n    }\r\n\r\n    state.pos += match[0].length;\r\n    return true;\r\n}","startLine":16,"endLine":49,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\ins.js","messages":[{"functionBody":"function ins(state, silent) {\r\n    var found, pos, stack, max = state.posMax, start = state.pos, lastChar, nextChar;\r\n\r\n    if (state.src.charCodeAt(start) !== 0x2B) {\r\n        return false;\r\n    }\r\n\r\n    if (silent) {\r\n        return false;\r\n    }\r\n\r\n    if (start + 4 >= max) {\r\n        return false;\r\n    }\r\n\r\n    if (state.src.charCodeAt(start + 1) !== 0x2B) {\r\n        return false;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\r\n    nextChar = state.src.charCodeAt(start + 2);\r\n\r\n    if (lastChar === 0x2B) {\r\n        return false;\r\n    }\r\n\r\n    if (nextChar === 0x2B) {\r\n        return false;\r\n    }\r\n\r\n    if (nextChar === 0x20 || nextChar === 0x0A) {\r\n        return false;\r\n    }\r\n\r\n    pos = start + 2;\r\n\r\n    while (pos < max && state.src.charCodeAt(pos) === 0x2B) {\r\n        pos++;\r\n    }\r\n\r\n    if (pos !== start + 2) {\r\n        state.pos += pos - start;\r\n\r\n        if (!silent) {\r\n            state.pending += state.src.slice(start, pos);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    state.pos = start + 2;\r\n    stack = 1;\r\n\r\n    while (state.pos + 1 < max) {\r\n        if (state.src.charCodeAt(state.pos) === 0x2B) {\r\n            if (state.src.charCodeAt(state.pos + 1) === 0x2B) {\r\n                lastChar = state.src.charCodeAt(state.pos - 1);\r\n                nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\r\n\r\n                if (nextChar !== 0x2B && lastChar !== 0x2B) {\r\n                    if (lastChar !== 0x20 && lastChar !== 0x0A) {\r\n                        stack--;\r\n                    } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\r\n                        stack++;\r\n                    }\r\n\r\n                    if (stack <= 0) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        state.parser.skipToken(state);\r\n    }\r\n\r\n    if (!found) {\r\n        state.pos = start;\r\n        return false;\r\n    }\r\n\r\n    state.posMax = state.pos;\r\n    state.pos = start + 2;\r\n\r\n    if (!silent) {\r\n        state.push({\r\n            type: \"ins_open\",\r\n            level: state.level++\r\n        });\r\n\r\n        state.parser.tokenize(state);\r\n\r\n        state.push({\r\n            type: \"ins_close\",\r\n            level: --state.level\r\n        });\r\n    }\r\n\r\n    state.pos = state.posMax + 2;\r\n    state.posMax = max;\r\n    return true;\r\n}","startLine":5,"endLine":84,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\links.js","messages":[{"functionBody":"function links(state, silent) {\r\n    var labelStart, labelEnd, label, href, title, pos, ref, code, isImage = false, oldPos = state.pos, max = state.posMax, start = state.pos, marker = state.src.charCodeAt(start);\r\n\r\n    if (marker === 0x21) {\r\n        isImage = true;\r\n        marker = state.src.charCodeAt(++start);\r\n    }\r\n\r\n    if (marker !== 0x5B) {\r\n        return false;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    labelStart = start + 1;\r\n    labelEnd = parseLinkLabel(state, start);\r\n\r\n    if (labelEnd < 0) {\r\n        return false;\r\n    }\r\n\r\n    pos = labelEnd + 1;\r\n\r\n    if (pos < max && state.src.charCodeAt(pos) === 0x28) {\r\n        pos++;\r\n\r\n        for (; pos < max; pos++) {\r\n            code = state.src.charCodeAt(pos);\r\n\r\n            if (code !== 0x20 && code !== 0x0A) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (pos >= max) {\r\n            return false;\r\n        }\r\n\r\n        start = pos;\r\n\r\n        if (parseLinkDestination(state, pos)) {\r\n            href = state.linkContent;\r\n            pos = state.pos;\r\n        } else {\r\n            href = \"\";\r\n        }\r\n\r\n        start = pos;\r\n\r\n        for (; pos < max; pos++) {\r\n            code = state.src.charCodeAt(pos);\r\n\r\n            if (code !== 0x20 && code !== 0x0A) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\r\n            title = state.linkContent;\r\n            pos = state.pos;\r\n\r\n            for (; pos < max; pos++) {\r\n                code = state.src.charCodeAt(pos);\r\n\r\n                if (code !== 0x20 && code !== 0x0A) {\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            title = \"\";\r\n        }\r\n\r\n        if (pos >= max || state.src.charCodeAt(pos) !== 0x29) {\r\n            state.pos = oldPos;\r\n            return false;\r\n        }\r\n\r\n        pos++;\r\n    } else {\r\n        if (state.linkLevel > 0) {\r\n            return false;\r\n        }\r\n\r\n        for (; pos < max; pos++) {\r\n            code = state.src.charCodeAt(pos);\r\n\r\n            if (code !== 0x20 && code !== 0x0A) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (pos < max && state.src.charCodeAt(pos) === 0x5B) {\r\n            start = pos + 1;\r\n            pos = parseLinkLabel(state, pos);\r\n\r\n            if (pos >= 0) {\r\n                label = state.src.slice(start, pos++);\r\n            } else {\r\n                pos = start - 1;\r\n            }\r\n        }\r\n\r\n        if (!label) {\r\n            if (typeof label === \"undefined\") {\r\n                pos = labelEnd + 1;\r\n            }\r\n\r\n            label = state.src.slice(labelStart, labelEnd);\r\n        }\r\n\r\n        ref = state.env.references[normalizeReference(label)];\r\n\r\n        if (!ref) {\r\n            state.pos = oldPos;\r\n            return false;\r\n        }\r\n\r\n        href = ref.href;\r\n        title = ref.title;\r\n    }\r\n\r\n    if (!silent) {\r\n        state.pos = labelStart;\r\n        state.posMax = labelEnd;\r\n\r\n        if (isImage) {\r\n            state.push({\r\n                type: \"image\",\r\n                src: href,\r\n                title: title,\r\n                alt: state.src.substr(labelStart, labelEnd - labelStart),\r\n                level: state.level\r\n            });\r\n        } else {\r\n            state.push({\r\n                type: \"link_open\",\r\n                href: href,\r\n                title: title,\r\n                level: state.level++\r\n            });\r\n\r\n            state.linkLevel++;\r\n            state.parser.tokenize(state);\r\n            state.linkLevel--;\r\n\r\n            state.push({\r\n                type: \"link_close\",\r\n                level: --state.level\r\n            });\r\n        }\r\n    }\r\n\r\n    state.pos = pos;\r\n    state.posMax = max;\r\n    return true;\r\n}","startLine":11,"endLine":170,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\mark.js","messages":[{"functionBody":"function del(state, silent) {\r\n    var found, pos, stack, max = state.posMax, start = state.pos, lastChar, nextChar;\r\n\r\n    if (state.src.charCodeAt(start) !== 0x3D) {\r\n        return false;\r\n    }\r\n\r\n    if (silent) {\r\n        return false;\r\n    }\r\n\r\n    if (start + 4 >= max) {\r\n        return false;\r\n    }\r\n\r\n    if (state.src.charCodeAt(start + 1) !== 0x3D) {\r\n        return false;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\r\n    nextChar = state.src.charCodeAt(start + 2);\r\n\r\n    if (lastChar === 0x3D) {\r\n        return false;\r\n    }\r\n\r\n    if (nextChar === 0x3D) {\r\n        return false;\r\n    }\r\n\r\n    if (nextChar === 0x20 || nextChar === 0x0A) {\r\n        return false;\r\n    }\r\n\r\n    pos = start + 2;\r\n\r\n    while (pos < max && state.src.charCodeAt(pos) === 0x3D) {\r\n        pos++;\r\n    }\r\n\r\n    if (pos !== start + 2) {\r\n        state.pos += pos - start;\r\n\r\n        if (!silent) {\r\n            state.pending += state.src.slice(start, pos);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    state.pos = start + 2;\r\n    stack = 1;\r\n\r\n    while (state.pos + 1 < max) {\r\n        if (state.src.charCodeAt(state.pos) === 0x3D) {\r\n            if (state.src.charCodeAt(state.pos + 1) === 0x3D) {\r\n                lastChar = state.src.charCodeAt(state.pos - 1);\r\n                nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\r\n\r\n                if (nextChar !== 0x3D && lastChar !== 0x3D) {\r\n                    if (lastChar !== 0x20 && lastChar !== 0x0A) {\r\n                        stack--;\r\n                    } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\r\n                        stack++;\r\n                    }\r\n\r\n                    if (stack <= 0) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        state.parser.skipToken(state);\r\n    }\r\n\r\n    if (!found) {\r\n        state.pos = start;\r\n        return false;\r\n    }\r\n\r\n    state.posMax = state.pos;\r\n    state.pos = start + 2;\r\n\r\n    if (!silent) {\r\n        state.push({\r\n            type: \"mark_open\",\r\n            level: state.level++\r\n        });\r\n\r\n        state.parser.tokenize(state);\r\n\r\n        state.push({\r\n            type: \"mark_close\",\r\n            level: --state.level\r\n        });\r\n    }\r\n\r\n    state.pos = state.posMax + 2;\r\n    state.posMax = max;\r\n    return true;\r\n}","startLine":5,"endLine":84,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\newline.js","messages":[{"functionBody":"function newline(state, silent) {\r\n    var pmax, max, pos = state.pos;\r\n\r\n    if (state.src.charCodeAt(pos) !== 0x0A) {\r\n        return false;\r\n    }\r\n\r\n    pmax = state.pending.length - 1;\r\n    max = state.posMax;\r\n\r\n    if (!silent) {\r\n        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\r\n            if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\r\n                for (var i = pmax - 2; i >= 0; i--) {\r\n                    if (state.pending.charCodeAt(i) !== 0x20) {\r\n                        state.pending = state.pending.substring(0, i + 1);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                state.push({\r\n                    type: \"hardbreak\",\r\n                    level: state.level\r\n                });\r\n            } else {\r\n                state.pending = state.pending.slice(0, -1);\r\n\r\n                state.push({\r\n                    type: \"softbreak\",\r\n                    level: state.level\r\n                });\r\n            }\r\n        } else {\r\n            state.push({\r\n                type: \"softbreak\",\r\n                level: state.level\r\n            });\r\n        }\r\n    }\r\n\r\n    pos++;\r\n\r\n    while (pos < max && state.src.charCodeAt(pos) === 0x20) {\r\n        pos++;\r\n    }\r\n\r\n    state.pos = pos;\r\n    return true;\r\n}","startLine":5,"endLine":54,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\state_inline.js","messages":[{"functionBody":"function StateInline(src, parserInline, options, env, outTokens) {\r\n    this.src = src;\r\n    this.env = env;\r\n    this.options = options;\r\n    this.parser = parserInline;\r\n    this.tokens = outTokens;\r\n    this.pos = 0;\r\n    this.posMax = this.src.length;\r\n    this.level = 0;\r\n    this.pending = \"\";\r\n    this.pendingLevel = 0;\r\n    this.cache = [];\r\n    this.isInLabel = false;\r\n    this.linkLevel = 0;\r\n    this.linkContent = \"\";\r\n    this.labelUnmatchedScopes = 0;\r\n}","startLine":5,"endLine":33,"nodeType":"FunctionDeclaration"},{"functionBody":"function() {\r\n    this.tokens.push({\r\n        type: \"text\",\r\n        content: this.pending,\r\n        level: this.pendingLevel\r\n    });\r\n\r\n    this.pending = \"\";\r\n}","startLine":37,"endLine":44,"nodeType":"FunctionExpression"},{"functionBody":"function(token) {\r\n    if (this.pending) {\r\n        this.pushPending();\r\n    }\r\n\r\n    this.tokens.push(token);\r\n    this.pendingLevel = this.level;\r\n}","startLine":49,"endLine":56,"nodeType":"FunctionExpression"},{"functionBody":"function(key, val) {\r\n    for (var i = this.cache.length; i <= key; i++) {\r\n        this.cache.push(0);\r\n    }\r\n\r\n    this.cache[key] = val;\r\n}","startLine":62,"endLine":68,"nodeType":"FunctionExpression"},{"functionBody":"function(key) {\r\n    return key < this.cache.length ? this.cache[key] : 0;\r\n}","startLine":72,"endLine":74,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\sub.js","messages":[{"functionBody":"function sub(state, silent) {\r\n    var found, content, max = state.posMax, start = state.pos;\r\n\r\n    if (state.src.charCodeAt(start) !== 0x7E) {\r\n        return false;\r\n    }\r\n\r\n    if (silent) {\r\n        return false;\r\n    }\r\n\r\n    if (start + 2 >= max) {\r\n        return false;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    state.pos = start + 1;\r\n\r\n    while (state.pos < max) {\r\n        if (state.src.charCodeAt(state.pos) === 0x7E) {\r\n            found = true;\r\n            break;\r\n        }\r\n\r\n        state.parser.skipToken(state);\r\n    }\r\n\r\n    if (!found || start + 1 === state.pos) {\r\n        state.pos = start;\r\n        return false;\r\n    }\r\n\r\n    content = state.src.slice(start + 1, state.pos);\r\n\r\n    if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\r\n        state.pos = start;\r\n        return false;\r\n    }\r\n\r\n    state.posMax = state.pos;\r\n    state.pos = start + 1;\r\n\r\n    if (!silent) {\r\n        state.push({\r\n            type: \"sub\",\r\n            level: state.level,\r\n            content: content.replace(UNESCAPE_RE, \"$1\")\r\n        });\r\n    }\r\n\r\n    state.pos = state.posMax + 1;\r\n    state.posMax = max;\r\n    return true;\r\n}","startLine":8,"endLine":58,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\sup.js","messages":[{"functionBody":"function sup(state, silent) {\r\n    var found, content, max = state.posMax, start = state.pos;\r\n\r\n    if (state.src.charCodeAt(start) !== 0x5E) {\r\n        return false;\r\n    }\r\n\r\n    if (silent) {\r\n        return false;\r\n    }\r\n\r\n    if (start + 2 >= max) {\r\n        return false;\r\n    }\r\n\r\n    if (state.level >= state.options.maxNesting) {\r\n        return false;\r\n    }\r\n\r\n    state.pos = start + 1;\r\n\r\n    while (state.pos < max) {\r\n        if (state.src.charCodeAt(state.pos) === 0x5E) {\r\n            found = true;\r\n            break;\r\n        }\r\n\r\n        state.parser.skipToken(state);\r\n    }\r\n\r\n    if (!found || start + 1 === state.pos) {\r\n        state.pos = start;\r\n        return false;\r\n    }\r\n\r\n    content = state.src.slice(start + 1, state.pos);\r\n\r\n    if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\r\n        state.pos = start;\r\n        return false;\r\n    }\r\n\r\n    state.posMax = state.pos;\r\n    state.pos = start + 1;\r\n\r\n    if (!silent) {\r\n        state.push({\r\n            type: \"sup\",\r\n            level: state.level,\r\n            content: content.replace(UNESCAPE_RE, \"$1\")\r\n        });\r\n    }\r\n\r\n    state.pos = state.posMax + 1;\r\n    state.posMax = max;\r\n    return true;\r\n}","startLine":8,"endLine":58,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\lib\\rules_inline\\text.js","messages":[{"functionBody":"function isTerminatorChar(ch) {\r\n    switch (ch) {\r\n    case 0x0A:\r\n    case 0x5C:\r\n    case 0x60:\r\n    case 0x2A:\r\n    case 0x5F:\r\n    case 0x5E:\r\n    case 0x5B:\r\n    case 0x5D:\r\n    case 0x21:\r\n    case 0x26:\r\n    case 0x3C:\r\n    case 0x3E:\r\n    case 0x7B:\r\n    case 0x7D:\r\n    case 0x24:\r\n    case 0x25:\r\n    case 0x40:\r\n    case 0x7E:\r\n    case 0x2B:\r\n    case 0x3D:\r\n    case 0x3A:\r\n        return true;\r\n    default:\r\n        return false;\r\n    }\r\n}","startLine":9,"endLine":36,"nodeType":"FunctionDeclaration"},{"functionBody":"function text(state, silent) {\r\n    var pos = state.pos;\r\n\r\n    while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\r\n        pos++;\r\n    }\r\n\r\n    if (pos === state.pos) {\r\n        return false;\r\n    }\r\n\r\n    if (!silent) {\r\n        state.pending += state.src.slice(state.pos, pos);\r\n    }\r\n\r\n    state.pos = pos;\r\n    return true;\r\n}","startLine":38,"endLine":52,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\support\\demodata.js","messages":[]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\support\\entities.js","messages":[{"functionBody":"function codeToUni(code) {\r\n    var result = code.toString(16).toUpperCase();\r\n\r\n    while (result.length < 4) {\r\n        result = \"0\" + result;\r\n    }\r\n\r\n    return \"\\\\u\" + result;\r\n}","startLine":11,"endLine":15,"nodeType":"FunctionDeclaration"},{"functionBody":"function strToUni(str) {\r\n    var result = codeToUni(str.charCodeAt(0));\r\n\r\n    if (str.length > 1) {\r\n        result += codeToUni(str.charCodeAt(1));\r\n    }\r\n\r\n    return result;\r\n}","startLine":17,"endLine":23,"nodeType":"FunctionDeclaration"},{"functionBody":"function(res) {\r\n    var body = \"\";\r\n\r\n    res.on(\"data\", function(chunk) {\r\n        body += chunk;\r\n    });\r\n\r\n    res.on(\"end\", function() {\r\n        var entities = JSON.parse(body);\r\n        var out = {};\r\n\r\n        Object.keys(entities).forEach(function(entity) {\r\n            if (entity[entity.length - 1] !== \";\") {\r\n                return;\r\n            }\r\n\r\n            out[entity.slice(1, -1)] = strToUni(entities[entity].characters);\r\n        });\r\n\r\n        var result = [];\r\n\r\n        Object.keys(out).forEach(function(key) {\r\n            result.push(\"  \\\"\" + key + \"\\\": \\\"\" + out[key] + \"\\\"\");\r\n        });\r\n\r\n        console.log(\"{\\n\" + result.join(\",\\n\") + \"\\n}\");\r\n    });\r\n}","startLine":25,"endLine":49,"nodeType":"FunctionExpression"},{"functionBody":"function(chunk) {\r\n    body += chunk;\r\n}","startLine":27,"endLine":29,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    var entities = JSON.parse(body);\r\n    var out = {};\r\n\r\n    Object.keys(entities).forEach(function(entity) {\r\n        if (entity[entity.length - 1] !== \";\") {\r\n            return;\r\n        }\r\n\r\n        out[entity.slice(1, -1)] = strToUni(entities[entity].characters);\r\n    });\r\n\r\n    var result = [];\r\n\r\n    Object.keys(out).forEach(function(key) {\r\n        result.push(\"  \\\"\" + key + \"\\\": \\\"\" + out[key] + \"\\\"\");\r\n    });\r\n\r\n    console.log(\"{\\n\" + result.join(\",\\n\") + \"\\n}\");\r\n}","startLine":30,"endLine":48,"nodeType":"FunctionExpression"},{"functionBody":"function(entity) {\r\n    if (entity[entity.length - 1] !== \";\") {\r\n        return;\r\n    }\r\n\r\n    out[entity.slice(1, -1)] = strToUni(entities[entity].characters);\r\n}","startLine":34,"endLine":39,"nodeType":"FunctionExpression"},{"functionBody":"function(key) {\r\n    result.push(\"  \\\"\" + key + \"\\\": \\\"\" + out[key] + \"\\\"\");\r\n}","startLine":43,"endLine":45,"nodeType":"FunctionExpression"}]},{"filePath":"C:\\DEV\\projects\\_git\\ossf-cve-benchmark\\sources\\CVE-2017-16006\\6da96c34ca5a3e2ab25ef36a62fe29377bdda9ff\\support\\specsplit.js","messages":[{"functionBody":"function readFile(filename, encoding, callback) {\r\n    if (options.file === \"-\") {\r\n        var chunks = [];\r\n\r\n        process.stdin.on(\"data\", function(chunk) {\r\n            chunks.push(chunk);\r\n        });\r\n\r\n        process.stdin.on(\"end\", function() {\r\n            return callback(null, Buffer.concat(chunks).toString(encoding));\r\n        });\r\n    } else {\r\n        fs.readFile(filename, encoding, callback);\r\n    }\r\n}","startLine":37,"endLine":53,"nodeType":"FunctionDeclaration"},{"functionBody":"function(chunk) {\r\n    chunks.push(chunk);\r\n}","startLine":43,"endLine":45,"nodeType":"FunctionExpression"},{"functionBody":"function() {\r\n    return callback(null, Buffer.concat(chunks).toString(encoding));\r\n}","startLine":47,"endLine":49,"nodeType":"FunctionExpression"},{"functionBody":"function(error, input) {\r\n    var good = [], bad = [], markdown = new Remarkable(\"commonmark\");\r\n\r\n    if (error) {\r\n        if (error.code === \"ENOENT\") {\r\n            process.stderr.write(\"File not found: \" + options.spec);\r\n            process.exit(2);\r\n        }\r\n\r\n        process.stderr.write(error.stack || error.message || String(error));\r\n        process.exit(1);\r\n    }\r\n\r\n    input = input.replace(/â†’/g, \"\\t\");\r\n\r\n    input.replace(\r\n        /^\\.\\n([\\s\\S]*?)^\\.\\n([\\s\\S]*?)^\\.$/gm,\r\n        function(__, md, html, offset, orig) {\r\n            var result = {\r\n                md: md,\r\n                html: html,\r\n                line: orig.slice(0, offset).split(/\\r?\\n/g).length,\r\n                err: \"\"\r\n            };\r\n\r\n            try {\r\n                if (markdown.render(md) === html) {\r\n                    good.push(result);\r\n                } else {\r\n                    result.err = markdown.render(md);\r\n                    bad.push(result);\r\n                }\r\n            } catch (___) {\r\n                bad.push(result);\r\n            }\r\n        }\r\n    );\r\n\r\n    if (!options.type) {\r\n        console.log(\r\n            util.format(\"passed samples - %s, failed samples - %s\", good.length, bad.length)\r\n        );\r\n    } else {\r\n        var data = options.type === \"good\" ? good : bad;\r\n\r\n        data.forEach(function(sample) {\r\n            console.log(util.format(\r\n                \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\" + \"src line: %s\\n\\n.\\n%s.\\n%s.\\n\",\r\n                sample.line,\r\n                sample.md,\r\n                sample.html\r\n            ));\r\n\r\n            if (sample.err) {\r\n                console.log(util.format(\"error:\\n\\n%s\\n\", sample.err));\r\n            }\r\n        });\r\n    }\r\n\r\n    process.exit(0);\r\n}","startLine":58,"endLine":112,"nodeType":"FunctionExpression"},{"functionBody":"function(__, md, html, offset, orig) {\r\n    var result = {\r\n        md: md,\r\n        html: html,\r\n        line: orig.slice(0, offset).split(/\\r?\\n/g).length,\r\n        err: \"\"\r\n    };\r\n\r\n    try {\r\n        if (markdown.render(md) === html) {\r\n            good.push(result);\r\n        } else {\r\n            result.err = markdown.render(md);\r\n            bad.push(result);\r\n        }\r\n    } catch (___) {\r\n        bad.push(result);\r\n    }\r\n}","startLine":74,"endLine":93,"nodeType":"FunctionExpression"},{"functionBody":"function(sample) {\r\n    console.log(util.format(\r\n        \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\" + \"src line: %s\\n\\n.\\n%s.\\n%s.\\n\",\r\n        sample.line,\r\n        sample.md,\r\n        sample.html\r\n    ));\r\n\r\n    if (sample.err) {\r\n        console.log(util.format(\"error:\\n\\n%s\\n\", sample.err));\r\n    }\r\n}","startLine":100,"endLine":108,"nodeType":"FunctionExpression"}]}]